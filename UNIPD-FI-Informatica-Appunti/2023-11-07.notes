[2023-11-07]
# Alternative multiple

    ## Sequenze di confronti
        - se si hanno più di due alternative, si usa una sequenza di confronti
        [java]
            if (richter >= 8)
                System.out.println("Terremoto molto forte");
            else if (richter >= 6)
                System.out.println("Terremoto forte");
            else if (richter >= 4)
                System.out.println("Terremoto medio");
            else if (richter >= 2)
                System.out.println("Terremoto debole");
            else if (richter >= 0)
                System.out.println("Terremoto molto debole");
            else
                System.out.println("Numeri negativi non validi");
        [/java]
        - l'ordine e la sequenza sono importanti
        - se si fanno confronti di tipo "maggiore di" si devono prima scrivere i valori più alti, e viceversa.
        - se non si rendono mutuamente esclusive le alternative, usando le clasuole "else", non funziona

    ## Diramazioni annidate
        - Caso di studio:
            Calcoliamo le tasse secondo le aliquote del sistema federale americano nel 2008
            [java]
                public class TaxReturn
                {
                    // variabili d'istanza
                    private int status;
                    private double income;

                    // costanti
                    public static final int SINGLE = 1;
                    public static final int MARRIED = 2;

                    public static final double RATE1 = 0.10;
                    public static final double RATE2 = 0.25;

                    public static final double SINGLE_LIMIT = 32000;
                    public static final double MARRIED_LIMIT = 64000;


                    public TaxReturn(int aStatus, double anIncome)
                    {
                        status = aStatus; income = anIncome;
                    }
                }
            [/java]
            (piccola prova fatta in TaxCalculator.java)
    ## il problema dell'else sospeso
        - nell'esempio seguente i livelli di rientro suggeriscono che la clausola else si riferisca al primo enunciato if
        [java]
            if (richter >=0)
                if (richter <= 4)
                    ...
            else                     // non funziona!!
                ...
        [/java]
        - compilatore ignora i rientri
            - risultati ottenuti errari
            - regola sintattica è che ! una clausola else appartiene sempre all'eunciato if più vicino!
        - per ottenere il risultato voluto, bisogna "nascondere" il secondo enunciato if all'interno di un blocco di enunciati, inserendo una coppia di parentesi graffe.
        [java]
            if (richter >=0)
            {

                if (richter <= 4)
                {
                    ...
                }
            }
            else
            {
                ...
            }
        [/java]
    
    ## Visibilità delle variabili
        - se il valore finale di una variabile usata nel corpo di un enunciato if/else deve essere visibile al di fuori del corpo, bisogna definirlo PRIMA dell'enunciato if/else
        - poiché una variabile definita nel corpo di un enunciato if/else non è più definita dopo di esso, è possibile usare di nuovo lo stesso nome successivamente nel codice (ma fare molta attenzione
        
        [java]
            double b = ...;
            if (b < 10)
            {
                double c = ...;
                // modifica b e c ...
            }
            // qui b è visibile, ma c no
        [/java]

    (esercizio in classe, PunteggioGiocatori.java)

# Conversione di stringhe in Numeri
- A volte si ha una stringa che continene un valore numerico e si vuole assegnare tale valore a una variabile di tipo numerico, per poi elaborarlo
[java]
    String password = "md50";
    String ageString = password.substring(2);
    // ageString contiene "50"
    // NON FUNZIONA
    int age = ageString;
[/java]
- il compilatore segnala l'errore semantico perché non si può convertire automaticamente una stringa in un numero, dato che non vi è certezza che il suo contenuto rappresenti un valore numerico.
- la conversione corretta si ottiene invocando il metodo statico "parseInt" della classe "Integer"
[java]
    int age = Integer.parseInt(ageString);
    // age contiene il numero 50
[/java]
- la conevrsione di un numero in viggola mobile si otteiene, analogamente, invocando il metodo statico "parseDouble" della classe "Double".
[java]
    String numberString = "34.3";
    double number = Double.parseDouble(numberString);
    // number contiene il numero 34.3
[/java]
- NON viene usata la localizzazione, quindi la stringa deve contenere sempre il punto come separatore decimale.
- oppure usare notazione scientifica.
- Cosa succede se la stringa passata come argomento non contiene un numero? 
- i metodi Integer.parseInt e Double.parseDouble lanciano un'eccezione di tipo "NumberFormatException" e il programma termina segnalando l'errore
- Il meccaniscmo generale di segnalazione di errori in Java consiste nel fare un throw di un'eccezione

# Espressioni booleane
- Ogni espressione ha un valore
    - x + 10 espressione aritmetica, valore numerico
    - x < 10 espressione relazionale, valore booleano
- un'espressione relazionale ha un valore vero o falso (true or false)
- i valore true e false non sono numeri, ne oggetti, ne classi: appartengono ad un tipo di dati diverso, detto booleano.
- è un tipo fondamentale in java, come quelli numerici
- i tipi di dati boolean, come tutti gli altri tipi di dati, consente la definizione di variabili e l'assegnazione di valori
    boolean a = true;
- a volte è comodo utilizzare variabili booleane per memorizzare valori di passaggi intermedi in cui è opportuno scomporre verifiche troppo complesse.
- altre volte l'uso di una variabile booleana rende più leggibile il codice
- spesso le variabili booleane vengono chiamate flags, perché possono assumere soltanto due valori, cioè trovarsi in due soli stati possibili

    ## Operatori booleani
    - Gli operatori booleani o logici servono a svolgere operazioni su valori booleani
    [java]
        if (x > 10 && x < 20) // esegue se x è maggiore di 10 e minore di 20
    [/java]
    - l'operatore "&&" (and) combina due o più combinazioni in una sola, che risulta vera se e solo se tutte sono vere
    - l'operatore "||" (or) combina due o più condizioni in una sola, che risulta vera se e solo se almeno una è vera
    - l'operatore "!" (not) inverte il valore di un'espressione booleana
    - più operatori booleani possono essere usati in un'unica espressione
        [java]
        if ((x > 10 && x < 20) || x > 30) {...}
        [/java]
    - la valutazione di un'espressione con operatori booleani viene effettuata con uan strategia detta "cortocircuito"
        - la valutazione dell'espressione termina appena è possibile decidere il risultato
    - in un'espressione booleana con più operatori, la valutazione viene fatta da sinistra a destra, dando la precedenza all'operatore not, poi all'operatore and, infine all'operatore or
    - l'ordine di valutazione può comunque essere alterato dalle parentesi tonde
    [java]
        if (!(x<0 || x>10)){...}
        // esegue se x è compreso tra 0 e 10, estremi inclusi
        if (!x<0 || x>10){...}
        // esegue se x è maggiore o uguale a 0
    [/java]