[2023-10-11]
== Intro Java ==

-= Compilare un file Java =-
    javac è il comando per compilare un file con estensione .java

-= JVM =-
    - è un programma che ha lo scopo di eseguire altri programmi
    - permette di eseguire programmi java 
    - Prende il bytecode e traduce in codice macchina da poi mandare nella cpu reale
    - codice sorgente => compilatore => file di bytecode => linterprete => programma in esecuzione

-= Compilatore e o interprete =-
    - Il fdatto che un linguaggio sia compilato o interpretato influisce fortemente su
        + quanto è facile eseguire lo stesso programma su computer aventi diverse cpu (portabilità)
        + velocità in esecuzione di un programma (efficienza)
    - Il linguaggio Java, da questo punto di vista, è un linguaggio misto, essendo sia compilato sia interpretato, in fasi diverse

-= Portatbilità =-
    - i programmi scritti in un linguaggio interpretato sono portabilità
    - i programmi scritti in un linguaggio compilato
        + sono portabili a livello di file sorgente, ma necessario compilare il programma su ogni cpu diversa

-= Take Home Message =-
    - I linguaggi di programmazione sono un compromesso tra linguaggio naturale e linguaggio macchina
    - Diversi tipi di programmazione
    - Java: molto utilizzato, buon compromesso

-= codice terminal per compilare ed eseguire =-
    - javac nomefile.java
    - java nome public class

-= Appunti =-
    - Occorre fare molta attenzione
        - Il testo va inserito esattamente come è presentato
        - Maiuscole e minuscole sono distinte
        - nome file deve avere il stesso nome della public class

[java]
    
    public class Hello // 1.) nome del programma
    {
        public static void main(String[] args) // 2.) metodo
        {
            System.out.println("Hello, world!"); // 3.) istruzioni, enunciati
        }
    }

[end]

-= Analisi codice =-
    1.  Prima riga "public class Hello" definisce una nuova classe
        - Le classi sono contenitori o fabbriche di oggetti e rappresentano un concetto fondamentale in java, che è un linguattio ad oggetti
            + Per il momento consideriamo gli oggetti come elementi da manipolare in un programma Java
            + Classi correlate possono essere raggruppate per formare un Package
        a. "Public" è una parola chiave che indica che la classe Hello può essere utilizzata da tutte le altre classi
            + le parole chiavi sono parole "riservate" del linguaggio che vanno scritte esattamente così come sono e non possono essere usate per altri scopi.
                - IMPORTANTE: Ciascun file sorgente può contenere una sola classe pubblica, il cui nome deve coincidere con il nome del file
    2.  per ora non usiamo le classi come fabbriche di oggetti, ma come contenitori di metodi
        - un "Metodo" serve a definire una sequenza di istruzioni o enunciati che descrive come svolgere un determinato compito.
            + in pratica definisce un algoritmo o una sua parte
        -   la costruzione 
                [java]
                    public static void main(String[] args)
                    {
                        ...
                    }
                [end]
            definisce il metodo main
        - un programma java deve avere un metodo "main"
        - public significa utilizzabile da tutti
        - invece, static significa che il metodo non esamina e non modifica gli oggetti della classe Hello a cui appartiene.
    
    **ENUNCIATI**
        ha lo scopo di eseguire un programma semplice, descritto da enunciati e contenuto nel file NomeClasse.java
        - gli enunciati che costituiscono un metodo vengono eseguiti nell'ordine in cui sono scritti
    
    3. Il "corpo" di un metodo è racchiuso tra parentesi graffe
        - Gli enunciati del corpo di un metodo vengono eseguiti uno alla volta nella sequenza in cui sono scritti
        - Ogni enunciato deve terminare con ";"
        - Il metodo main del nostro esempio ha un solo enunciato, che visualizza una riga di testo
            + Dove la visualizza? Un programma può inserire testo in una finsestra, scriverlo in un file o anche inviarlo ad un altro computer attraverso internet.
        [java]
            System.out.println("...");
        [end]
            - Nel nostro aso la destrinazione è l'output_standard
                - è una proprietà di ciascun programma che dipende dal sistema operativo del computer
            - all'interno di un programma java, l'output_standard è rappresentato da un oggetto di nome out
                - come ogni metodo, anche gli oggetti devono essere inseriti in classi: out è inserito nella classe System della lbireria standard, che contiene oggetti e metodi da utilizzare per accedere alla risorse di sistema
                - per usare l'oggetto out della classe System si scrive
                    [java]
                        System.out
                    [end]
            - quando si usa un oggetto, bisogna specificare cosa si vuol fare con l'oggetto stesso
                - in questo caso vogliamo usare un metodo dell'oggetto out, il metodo println, che stampa una riga di testo
                - per usare il metodo println dell'oggetto System.out si scrive 
                    [java]
                        System.out.println(parametri);
                    [end]
                - la coppia di parentesi tonde racchiude le informazioni necessarie per l'esecuzione del metodo (parametri)
                - A volte il carattere "." significa "usa un oggetto di una classe", altre volte "usa un metodo di un oggetto": dipende dal contesto...
                    - molte grammatiche (formali o naturali) hanno una sintassi dipendente dal contesto
            



[2023-10-12]
*------------------------------------------------------------*
| *** Rappresenzaione delle informazioni nei calcolatori *** |
*------------------------------------------------------------*

*** Obiettivi ***
- Bisogna imparare come vari tipi di dato vengono rappresentati all'interno del computer
    - Numeri naturali (interi senza segno)
        - Rappresentazione posizionale
    - Numeri interi
        - Rappresentazione modulo/segno
        - Rappresentazione in complemento a 2
    - Numeri reali
        - Rappresentazione a virgola fissa e mobile
    - Caratteri
        - ASCII e Unicode

*** Perche' e' importante studaire la rappresentazione dei dati ***
- Noi usiamo la notazione decimale per i numeri e dei simboli per le lettere
    - Il computer capisce 0-1
- I valori numerici sono infiniti
    - I Bit che il computer dedica alla rappresentazione dei numeri NON sono infiniti
        - Ci sono dei limiti alla rappresentazione dei valori numerici 
            - max/min valore rappresentazione
            - Precisione della rappresentazione
- I caratteri sono dei simboli, necessaria tabella di conversione

*-------------------------------*
| *** Notazione Posizionale *** |
*-------------------------------*

- I numeri che siamo abituati a utilizzare sono espressi
    - in base decimale perché usiamo dieci cifre diverse (da 0 a 9)
    - Con notazione posizionale perché cifre uguali in posizioni diverse hanno valore diverso
        - Il peso di una cifra è uguale alla base (10 in questo caso) elevata alla potenza della posizione della cifra 
            - La posizione si incrementa da destra a sinistra a partire da 0
- L'eventuale parte frazionaria, a destra del simbolo separatore, si valuta con potenze negative

*---------------------------*
| *** Notazione Binaria *** |
*---------------------------*

- I computer usano invece i numeri binari, cioè numeri rappresentati con notazione posizionale in base Binaria
    - la base binaria usa solo due cifre diverse, 0 e 1
        - in base X si usano le cifre da 0 a X-1
    - la conversione da base binaria a decimale è semplice
    
        (1101)sub2 = (1*1^3 + 1*1^2 + 0*2^1 + 1*2^0)sub10 = (13)sub10
        (1.01)sub2 = (1*1^0 + 1*1^-1 + 0*2^-2 + 1*2^-3)sub10 = (1.625)sub10

    - La rappresentazione binaria è più facile da manipolare per i computer per motivi tecnologici
        - perché è meno complicato costruire circuiti logici (digitali) che distinguono tra "acceso" e "spento".
- La conversione di un numero da base decimale a base binaria è, invece, un po' più complessa
- La parte intera del numero va elaborata indipendentemente dalla eventuale parte frazionaria.

*** Convertire la parte intera ***
- Per convertire la sola parte intera:
    - si divide il numero per 2
    - si elimina l'eventuale resto
    - si continua a dividere per 2 il quozioente ottenuto fino a quando non si ottiene quozioente uguale a 0
    - Il numero binario si ottiene scrivendo la sequenza dei resti delle divisioni, iniziando dall'ultimo resto ottenuto
    - ATTENZIONE: non fermarsi quando si ottiene quoziente 1, ma proseguire fino a 0.

        #CONVERTIRE LA PARTE INTERA ES. 100base10
        100    /    2    =    50 resto 0
        50     /    2    =    25 resto 0
        25     /    2    =    12 resto 1
        12     /    2    =    6  resto 0
        3      /    2    =    1  resto 1
        1      /    2    =    0  resto 1

        (100)base10      =    (110100)base2

*** Convertire la parte frazionaria ***

- Per convertire la sola parte frazionaria:
    - si moltiplica il numero per 2
    - si sottrae 1 dal prodotto se questo e' maggiore di 1
    - continuo fino a che il risultato e' uguale a 0 oppure e' un risultato gia' ottenuto
        - se si ottiene un risultato gia' ottenuto in precedenza, il numero sara' periodico, anche se non lo era in base decimale.
    - il numero binario si ottiene scrivendo la sequenza delle parti intere dei prodotti ottenuti, iniziando dal primo.

        #CONVERTIRE 0.35d
        0.35    *   2   =   0.7
        0.7     *   2   =   1.4
        0.4     *   2   =   0.8
        0.8     *   2   =   1.6
        0.6     *   2   =   1.2
        0.2     *   2   =   0.4
        (0.35)base10    =   (0.010110)base2

*** Rappresentazione in virgola fissa ***

- La rappresentazione completa si ottiene componendo la parte intera e quella frazionaria
- Rappresentazione in virgola fissa: il separatore si trova sempre nello stesso punto rispetto alla sequenza di bit.

    (100.35)base10  =  (110100.010110)base2


Abbiamo visto che per i numeri interi non negativi si usa la rappresentazione binaria posizionale.
    (101100)base2 = (44)base10
Se si usa una rappresentazione a n bit, si possono rappresentare i 2^n numeri naturali che sono compresi nell'intervallo [0, (2^n)-1] ∩ Z

- Con 8 cifre binarie (cioè 8 bit) si possono rappresentare 2^8 configurazioni, pari a 256 numeri diversi.

*** NUMERI INTERI RELATIVI ***
- Come possiamo rappresentare i numeri negativi?
    - la rappresentazione più "naturale" o intuitiva è quella con modulo e segno
        - si rappresenta il segno positivo o negativo del numero con il primo bit della sequenza (quello più a sinistra, ovvero il più significativo)
            - 0 rappresenta +
            - 1 rappresenta -
        - si rappresenta il modulo o valore assoluto del numero (che ovviamente è un numero non negativo)
            - utilizzando i restanti bit a disposizione
            - con la notazione binaria posizionale vista per i numeri non negativi
        - Esempio: rappresentazione usando 6 bit
            - 1 bit di segno
            - 5 bit destinati al valore assoluto del numero
                - il loro spazio viene riempito di zeri a sinistra, dopo il bit del segno, se serve
            
            (101100)2ms = (-12)base10
            (001100)2ms = (12)base10
        - se si usa una rappresentazione a n bit modulo/segno
            - si possono rappresentare (2^n)-1 numeri interi nell'intervallo
                [ -(2^(n-1) - 1) , 2^(n-1) - 1] ∩ Z 
        -  in pratica non si usa
            - problema: c'è una doppia rappresentazione per lo zero, per cui si "spreca" una configurazione
            - problema (più grave): l'algoritmo per l'addizione di numeri così rappresentati è complesso
    - Complemento a due
        - una rappresentazione più efficiente è quella denominata "complemento a 2", così definita
            - dato un numero intero relativo
                 a ∈ [-2^(n-1) , 2^(n-1)-1] ∩ Z
              la sua rappresentazione in complemento a due con n bit è

            C2(base n) (a) = - rappresentazione binaria di a con n bit se a ≥ 0
                             - rappresentazione binaria di (a+2^n) con n bit se a < 0
            


[2023-10-13]
Notes:

*** PER CASA ***
- Esercizio: Scrivere un programma java che chieda all'utente le lunghezze A B e C dei tre lati di un triangolo e stabilisca se esso è rettangolo oppure no.
- Suggerimento:
+ Algoritmo verificaSeRettangolo
+ var A, B, C double
+ Inserisci A
+ Inserisci B
+ Inserisci C
+ Se (a*a==b*b+c*c || ...) = condizione vera
+ se condizione vera = "il triangolo è rettangolo"
+ altrimenti = "Il triangolo non è rettangolo"



[2023-10-19]

*** TIPI DI DATO IN JAVA ***
- Java è un linguaggio fortemente tipizzato e quindi ogni dato è di un ben preciso tipo noto al momento della compilazione del programma
- i tipi di dati in java possono essere:
    - tipi primitivi
        - tipologie semplici di dati
    - riferimenti ad un oggetto

# Dati primitivi
- Boolean
    - vero o falso
- Number
    - integer
        - byte
            - 1 byte
            - -128 a 127
            - variabile con segno che rappresenta valori in un range [-128 e 127] (estremi inclusi)
        - short
            - 2 byte
            - -32768 a 32767
            - numeri interi (con segno) in un range [-32768 a 32767]
        - int
            - 4 byte
            - -2*10^9 a 2*10^9 circa
            - numeri intero (per default con segno, signed) in un range[-2^31 a 2^31-1]
        - long
            - 8 byte
            - -10^20 a 10^20 circa
        - char
            - 2 byte
            - 0 a 65535 unicode
    - floating-point
        - float
            - precisione singola
            - +- 10^38 cifre significative
            - numeri in virgola mobile in singola precisione secondo la specifica IEEE754
        - double
            - precisione doppia
            - +- 10^308, 15 cifre significative

Una variabile "int" è rappresentata con 32 bit in complemento a 2. Quindi il massimo numero esprimibile è 2^31 - 1 = 2147483647.

# Valori Massimi e Minimi
- Se servono i valori massimi/minimi dei numeri rappresentati con i vari tipi di dati non occorre ricordarli
- il pacchetto java.lang della libreria standard contiene una classe per ciascun tipo di dati fondamentali, in cui sono definiti questi valori come costanti.

* ! OCIO ! *
!! In java tutti i tipi di dati fondamentali per numeri interi usano internamente la rappresentazione in complemento a due 
!! La JVM non segnala le condizioni di overflow nelle operazioni aritmetiche
!! L'unica operazione aritmetica tra numeri interi che genera una eccezione è la divisione con divisiore zero: "ArithmeticException"
!! Invece la divisione per zero un numero float/double si ottiene -/+ infinity
!! Quando l'intervallo di variabilità del tipo "int" non soddisfa le esigenze numeriche del problema, si usa il tipo long  
    - max valore assoluto con una variabile long: circa 9 miliardi di miliardi
    - per assegnare un valore a una variabile long bisogna aggiungere un carattere L alla fine (Java assume che le costanti numeriche siano interi)
        - long l = 123456789023424; ERRORE
        - long l = 123456789023424L; OK

# Variabili
- In Java ogni variabile ha
    - nome: identificativo che viene utilizzato per "usare" la variabile
    - tipo:
        - determina l'insieme dei valori amissibili (assegnabili)
        - determina l'occupazione in memoria
    - contenuto: valore associato
    - alcuni attributi: determinano la visibilità (public, protected, private) o specificano tipi particolari di variabili (static, final)
- sintassi: 
    nomeTipo nomeVariabile;
    nomeTipo nomeVariabile = espressione;
    - scopo: definire la nuova variabile "nomeVariabile", di tipo "nomeTipo", ed eventualmente assegnarle il valore iniziale "espressione".
    
    nomeVariabile = espressione;
    - scopo: assegnare il nuovo valore "espressione" alla variabile "nomeVariabile".

# Costante
- sintassi:
    final nomeTipo NOME_COSTANTE = espressione;
    - scopo: definire la costante "NOME_COSTANTE" di tipo "nomeTipo", assegnandole il valore espressione, che non potrà più essere modificato. 
        !!nota: il compilatore segnala come errore semantico il tentativo di assegnare un nuovo valore ad una costante, dopo la sua inizializzazione.


Di solito in Java si usa la seguente convenzione
    - i nomi di costanti sono formati da lettere maiuscole
    - i nomi composti si ottengono attaccando le parole successive alla prima con un carattere di sottolineatura

# Literals /1
I valori costanti (=literals) per i numeri sono interpretate da java come tipi int e double, a seconda che abbiamo o meno la parte frazionaria

- interi
    - se il valore ricade nell'intervallo di un tipo di dato meno capace (byte o short) all'ra l'assegnamento avviene senza problemi, altrimenti errore in compilazione
        
        [java]
        byte value1 = 10;       // OK
        byte value2 = 128;      // errore in compilazione
                                // max consentito 127

        short value3 = 200;     // OK
        short value4 = 33000;   // errore in compilazione
                                // max consentito 32767
        [/java]

    - se il valore è più grande del range del tipo "int", ma rientra nel range del tipo "long", devo esplicitare che si tratta di un valore long, aggiungendo "L" alla fine del numero

        [java]
        long l = 1345845486748064820L;       // OK
        long l = 1345845486748064820;        // errore in compilazione
        [/java]

- numeri in virgola mobile
    - anche se il valore ricade nell'intervallo del tipo float ho errore in compilazione
    - devo esplicitamente dire che il valore va interpretato come float per poterlo assegnare.. aggiungo f alla fine del numero
    - posso anche inizializzare un numero in virgola mobile con un valore intero.. in questo caso semplicemente la parte frazionaria corrisponderà a 0.
        
        [java]
        float f1 = 2.35;   // ERRORE
        float f2 = 2.35f;  // OK
        float f3 = 2;      // OK
        System.out.println(f3);  // stampa: 2.0
        [/java]
    
    !!nota: non ci sono solo valori costanti numerici. Anche le stringhe o i caratteri hanno "literals".

        [java]
        char c = 'A';
        String name = "Giacomo";
        [/java]

# Promozioni e casting
Può capitare di dover spostare dei valori numerici fra variabili di tipo diverso
    - se un valore contenuto in una variabile di un certo tipo deve essere assegnato ad una variabile di un tipo "più capace", ad esempio: 
        
        [java]
        byte b = 100;
        int i = b;
        // OK!!
        [/java]

    il compilatore esegue una conversione automatica (promozione).
    - se un valore contenuto in una variabile di un certo tipo deve essere assegnato ad una variabile di un tipo "meno capace", il cimpilatore non esegue una conversione perché potrebbe portare alla perdita di cifre significative. 
        - provoca un errore in compilazione
    
# Operatori Aritmetici
- L'operatore che indica la divisione è "/", quello che indica la moltiplicazione è "*"
- il punto è il separatore deciale
- non bisogna indicare il punto separatore delle migliaia
- Numeri in virgola mobile si possono indicare anche in notazione esponenziale
    [java]
    1.93E3 // vale 1.93x10^3
    [java]
- L'operatore di moltiplicazione va indicato esplicitamente, non può essere sottointeso
- Le operazioni di moltiplicazione e divisione hanno la precedenza
- è possibile usare coppie di parentesi TONDE per indicare in quale ordine valutare le sotto-espressioni
        a + b / 2 != (a + b) / 2
- In Java non esiste il simbolo di frazione, le frazioni vanno espresse inline
- le operazioni di moltiplicazione e divisione hanno la precedenza
- è possibile usare coppie di parentesi tonde per indicare l'ordine
- quando entrambi gli operandi sono interi, la divisione calcola il quoziente intero scartando il resto
        7 / 4 = 1 
        7.0/4 && 7.0/4.0 && 7/4.0 = 1.75
- il resto della divisione può essere calcolato usando "%"
        7 % 4 = 3


La classe math della libreria standard mette a disposizione metodi statii per il calcolo di tutte le funzioni algebriche e trigonometriche.
- Math.pow(x,y) restituisce x^y
- Math.sqrt(x) restituisce radice quadrata di x
- Math.log(x) restituisce logaritmo naturale di x
- Math.sin(x) restituisce il seno di x espresso in radicanti

Methodi di Math vs println:
- println agisce su un oggetto (ad esempio System.out)
    - ricordiamo che per il momento, consideriamo gli oggetti come elementi da manipolare in un programma Java
- pow non agisce su un oggetto (Math è una classe)
    - il metodo Math.pow è un metodo statico
- La sintassi è identica, ma tutte le classi, gli oggetti e i metodi della libreria standard seguono una rigida convenzione:
    - i nomi delle classi (Math, System) iniziano con una lettera maiuscola
    - i nomi di oggetti (out) e metodi (println, pow) iniziano con una lettera minuscola
        - oggetti e metodi si distinguono perché solo i metodi sono sempre seguiti dalle parentesi tonde

- public: il metodo può essere invocato in qualsiasi classe
- static: il metodo è statico
- double: tipo di dato restituito
- pow:    nome o identificatore del metodo
- double a, double b: parametri "espliciti" del ...

// -----------------------------------
[java]
    NomeClasse.nomeMetodo(parametri);
[/java]
    Scopo: invocare il metodo statico "nomeMetodo" definito nella classe "NomeClasse", fornendo gli eventuali "parametri" richiesti.
    Nota: un metodo statico non viene invocato con un oggetto, ma con un nome di classe
        - un metodo statico elabora o modifica solo i propri parametri espliciti
- Nella classe Math sono definite alcune costanti
    [java]
        public final class Math
        {
            public static final double PI = 3.141592658979323846;
            public static final double E = 2.7182818284590452354;
        }
    [/java]
- Sono costanti statiche, ovvero appartengono alla classe
- tali costanti sono di norma public e per ottenere il loro valore si usa il nome della classe seguito dal punto e dal nome della costante, Math.E, oppure Math.PI

# Combinare assegnazioni e aritmetica
- Per combinare in un singolo enunciato un'assegnazione ed un'espressione aritmetica che coinvolge la variabile a cui si assegna il risultato
    [java]
        totalEuro = totalEuro + dollars * 1.41;
    [/java]
- la via più veloce è 
    [java]
        totalEuro += dollars * 1.41;
    [/java]
- questo esiste per tutti gli operatori aritmetici
    [java]
        x = x * 2;
        x*=2;
    [/java]
# Incremento di una variabile
- L'incremento di una variabile che consiste nell'aumentarne il valore di uno
    [java]
        int counter = 0;
        counter = counter + 1;

        counter++;
    [/java]
- Funziona anche per il decremento
    [java]
        int counter = x;
        counter = counter - 1;

        counter--;
    [/java]

# Documentazione della libreria standard
- Le classi della libreria Java sono migliaia, esistono documentazioni
- L'ambiente JDK fornisce la documentazione API (Application Programming Interface) per l'utilizzo delle classi della libreria standard
- JDK inoltre fornisce:
    - tutta la documentazione per l'utilizzo delle classi della libreria standard
    - alcuni documenti in formato "tutorial" per la descrizione delle funzionalità di interi pacchetti
    - esempi di programmi ("demo")


# I pacchetti di classi (package)
- Tutte le classi della libreria standard sono raccolte in package e sono organizzate per argomento e/o finalità
- Per usare una classe di una libreria, bisogna importarla nel programma usando l'enunciato
    [java]
        import.nomePacchetto.nomeClasse;
    [/java]
- le classi System, Math e String appartengono al pacchetto java.lang
- il pacchetto java.lang viene importato automaticamente

        [java]
            import.nomePacchetto.nomeClasse;
        [/java]
        - Scopo: importare una classe da una pacchetto, per poterla utilizzare in un programma. 
        [java]
            import.nomePacchetto.*;
        [/java]
        - Scopo: importare tutte le classi di un pacchetto, per poterle utilizzare in un programma.

    ## Stili per l'importazione delle classi
    - usare un enunciato import per ogni classe importata
        [java]
            import.math.BigInteger;
            import.math.BigDecimal;
        [/java]
    - usare un enunciato import che importa tutte le classi di un pacchetto
        [java]
            import java.math.*;
        [/java]
        - non è un errore importare classi che non si usano 
        - se si usano più enunciati di questo tipo, non è più chiaro il pacchetto di appartenenza di una classe
    - non usare per nulla gli enunciati import, ma indicare sempre il nome completo delle classi utilizzate nel codice
        [java]
            java.math.BigInteger a = new java.math.BigInteger("123456789");
        [/java]
        - questo stile è poco usato
            - più errori di battitura
            - più lungo il codice
            - più noioso
            - meno leggibile

# stringhe
    - I tipi di dati più importanti nella maggior parte dei programmi sono i numeri e le stringhe
    - Una stringa è una sequenza di caratteri, che in Java (come in molti altri linguaggi) vanno racchiusi tra virgolette
    - Possiamo dichiarare e inizializzare variabili di tipo stringa
        [java]
            String name = "Giacomo";
        [/java]
    - Possiamo assegnare un valore ad una variabile di tipo stringa
        [java]
            name = "Jack";
        [/java]
    - Diversamente dai numeri, le stringhe sono oggetti
    - Una variabile di tipo stringa può quindi essere utilizzata per invocare metodi (non statici) della classe String 
        - ad esempio, il metodo length restituisce la lunghezza di uan stringa, cioè il numero di caratteri presenti in essa (senza contare le virgolette)
        [java]
            String name = "Giacomo";
            int n = name.length();
        [/java]
        - il metodo "length" della classe String !! non è un metodo statico !!
            - infatti per invocarlo usiamo un oggetto della classe String e questo significa che il metodo funziona agendo su un oggetto
            [java]
                String s = "Giacomo";
                int n = s.length(); // FUNZIONA
                
                // ----------------------
                
                String s = "Giacomo";
                int n = String.length(); // NON FUNZIONA
            [/java]
        - una stringa di lunghezza zero, che non contiene caratteri, si chiama stringa vuota e si indica con due caratteri virgolette consecutivi, senza spazi interposti.
            [java]
                String empty = "";
                System.out.println(empty.length()); // 0
            [/java]

# Estrazioni di sottostringhe
    - per estrarre una sottostringa da una stringa si usa il metodo substring
        [java]
            String greeting = "Hello, World!";
            String sub = greeting.substring(0, 4); // contiene "Hell"
        [/java]
        - il primo parametro di substring è la posizione del primo carattere che si vuole usare
        - il secondo parametro è la posizione successiva all'ultimo carattero che si vuole usare

            H E L L O ,   W O R L D !
            0 1 2 3 4 5 6 7 8 9 10 11 12

        - la posizione dei caratteri nelle stringhe viene numerata a partire da 0 anziché da 1
            - uniformità con altri linguaggi
        !NOTE: 
            - la posizione dell'ultimo carattere corrisponde alla lunghezza della stringa meno 1
            - la differenza tra due parametri di substring corrisponde alla lunghezza della sottostringa estratta
    - Il metodo substring può essere invocato anche con un solo parametro
        [java]
            String greeting = "Hello, World!";
            String sub = greeting.substring(7); // contiene "World!"
        [/java]

# Concatenazione di stringhe 
    - Per concatenare due stringhe si usa l'operatore +
        [java]
            String s1 = "li";
            String s2 = "re";
            String s3 = s1 + s2; // s3 contiene "lire"
            int lit = 15000;
            String s = lit + s3; // s contiene "15000lire"
        [/java]
    - l'operatore + non aggiunge spazi
    - per avere lo spazio bisogna aggiungerlo
        [java]
            String s1 = "li";
            String s2 = "re";
            String s3 = s1 + s2; // s3 contiene "lire"
            int lit = 15000;
            String s = lit + ' ' + s3; // s contiene "15000 lire"
        [/java]

# Metodi utili di String
    - Un problema che capita spesso di affrontare è quello della conversione di una stringa per ottenerne un'altra tutta in maiuscolo o tutto in minuscolo
    - la classe String mette a disposizione due metodi
        - toUpperCase converte tutto in maiuscolo
        - toLowerCase converte tutto in minuscolo
    
        [java]
            Strong s = "Hello";
            String ss = s.toUpperCase() + s.toLowerCase(); // vs vale "HELLOhellO"
        [/java]
    - si noti che l'applicazione di uno di questi metodi alla stirnga s non altera il contenuto della stringa s, ma restituisce una nuova stringa
    - in particolare nessun metodo della classe String modifica l'oggetto con cui viene invocato
        - si dice perciò che gli oggetti della classe String sono oggetti immutabili

# Conversione di numeri in stringhe
    - per convertire un numero in stringa si può concatenare il numero con la stringa vuota
    [java]
        int ageNumber = 10;
        String ageString = "" + ageNumber; // ageString contiene "10"
    [/java]
    - è però più elegante e comprensibile utilizzare il metodo toString delle classi Integer e Double
    [java]
        int ageNumber = 10;
        String ageString = Integer.toString(ageNumber);
    [/java]



[2023-10-20]

# La classe scanner
- prima di tutto bisogna creare un oggetto della classe Scanner usando l'istruzione
    [java]
    Scanner console = new Scanner(System.in);
    [/java]

# I metodi nextInt() e nextDouble()
- il metodo nextInt restituisce un valore numerico di int
- è consigliabile inserire un emssaggio di richiesta prima di invocare un metodo di scanner
- il metodo nextDouble restituisce un valore numerico di double
- è consigliabile inserire un emssaggio di richiesta prima di invocare un metodo di scanner

!! Attenzione per nextDouble()
    - i progettisti di classe Scanner hanno usato la localizzazione
        - significa che il comportamento del programma è legato alla configurazione del sistema su cui viene fatto eseguire
    - a seconda della configurazione (anglosassone o italiana) un valore di tipo double dovrà essere inserito nella forma
        - parteIntera.parteDecimale ad esempio 4.35
        - parteIntera,parteDecimale ad esempio 4,35
- il metodo nextLine restituisce un oggetto di tipo String che contiene l'intera riga introdotta dall'utente (fino alla pressione del carattere Invio)



[2023-10-24]

# Sequenze di escape
- Se noi cerchiamo di stampare una string che contenga delle virgolette, semplicemente inserire le virgolette non funziona
- Il compilatore identifica le seconde virgolette come la fine della prima stringa
- Basta inserire un backslash prima delle virgolette all'interno della stringa.
    [java]
        System.out.println("Hello, "World"!");   // non funziona
        System.out.println("Hello, \"World\"!"); // funziona
    [/java]
- Il carattere backslash all'interno di una stringa non rappresenta se stesso, ma si usa per codificare altri caratteri che non si riesce ad includere facilmente in una stringa, a causa delle sequenze di escape. 
- Se devo inserire un backslash dentro la stringa, devo usare la sequenza di escape "\\". 
    [java]
        System.out.printlm("File C:\\test.exe"); // Il path vien fuori corretto "C:\test.exe
    [/java]
- Altra sequenza di escape comune è \n, per rappresentare il carattere di "new line"
- Le sequenze di escape si usano anche per inserire caratteri di lingue straniere o simboli che non si trovano sulla tastiera.

# Utilizzo di Classi e Oggetti
- Elaborando numeri e caratteri si possono scrivere programmi interessanti, ma programmi più utili hanno bisogno di manipolare dati più complessi
    - numeri complessi, conti bancari, dati anagrafici, forme grafiche, file audio, ecc
- Il linguaggio Java gestisce questi dati complessi sotto forma di Oggetti
- Gli oggetti e il loro comportamento vengono descritti mediante le Classi e i loro Metodi

    ## Programmazione ad oggetti
    - Paradigma di programmazione
        - Insieme di strumenti concettuali che cartterizzano un linguaggio di programmazione
    - Nella programmazione ad oggetti si utilizzano le classi come "fabbriche di oggetti"
    - Una classe: 
        a. Contiene dati e emtodi la cui realizzazione non è necessariamente nota
        b. Permette acecsso e/o modifica di dati tramite la sua interfaccia pubblica
            i. Incapsulamento: diversi livelli di astrazione

        ### Oggetti
        - Un oggetto è un'entità che può essere manipolata in un programma mediante l'invocazione di metodi 
        - Metodi: sequenze di istruzioni che possono accedere ai dati interni dell'oggetto
        - Immaginiamo un oggetto come una "scatola nera" dotata di: 
            a. un'interfaccia pubblica (insieme dei metodi che si possono utilizzare), che definisce il comportamento dell'oggetto
            b. una realizzazione (o implementazione) nascosta (dentro la "scatola": il codice dei metodi e i loro dati)

        ### Classi
        - Una classe è una fabbrica di oggetti o, meglio, uno schema di progetto per la costruzione di oggetti.
            - gli oggetti che si creano sono esemplari (o "istanze", instance) di una classe
        - specifica i metodi che si possono invocare con gli oggetti che sono esemplari di tale classe (l'interfaccia pubblica)
        - definisce i dettagli della realizzazione dei metodi (codice e dati)
        - è anche un contenitore di
            a. metodi statici (Hello contiene main)
            b. variabili statiche (System contiene out)

- Usare oggetti che siano istanze di una classe e realizzare una classe sono due attività ben distinte!

# Interfaccia pubblica
- L'interfaccia pubblica di una classe descrive i metodi che possono essere invocati da oggetti "fabbricati da quella classe (anche detti istanze o esemplari della classe)
- Per esempio, alcuni metodi della classe String sono: 
    a. length() che restituisce la lunghezza della stringa
    b. toUpperCase() che restituisce la stringa con tutte le lettere minuscole trasformate in maiuscolo

# definizione / inizializzazione di una variabile oggetto di tipo string
- per invocare un metodo di una classe che fabbrica oggetti (come String) devo prima creare un oggetto di quella classe e inizializzarlo
- per le stringhe posso dichiarare una variabile e usare l'assegnazione come si fa per i tipi primitivi 
    [java]
        String saluto = "Ciao, Mondo!"
    [/java]

# invocazione di metodi
- Per invocare un metodo della classe String, ad esempio length(), devo utilizzare una variabile di oggetto di tipo String che dica su che dati il metodo devo lavorare
    [java]
        nomeOggetto.nomeMetodo(parametri);
        
        String saluto = "Ciao, Mondo!"
        saluto.length();
    [/java]

# Metodi
- Se il metodo restituisce un valore di un certo tipo, posso assegnare questo valore ad una variabile di quello stesso tipo
    - ad esempio, length() restituisce un interno
    [java]
        String greeting = "Hello, World";
        int n = greeting.length();
    [/java]
    - ad esempio, toUpperCase() restituisce una stringa
    [java]
        String river = "Mississippi";
        String bigRiver = river.toUpperCase();
        System.out.println(bigRiver); // stampa MISSISSIPPI
    [/java]
- se il metodo restituisce un valore di un certo tipo, posso utilizzare questo valore come parametro esplicito di un altro metodo
- Istruzioni NON valide:
    !- con un oggetto che è un'istanza di una data classe posso invocare solo metodi messi a disposizione da quella classe
    !- out è un oggetto di tipo PrintStream. Questa classe non ha tra i suoi metodi il metodo length()

# Metodi: parametri espliciti/impliciti
- Alcuni metodi necessitano di valori di ingresso, o parametri espliciti, che specifichino i dati da elaborare
    [java]
        System.out.println(greeting);
    [/java]
    - greeting è un parametro esplicito: è la stringa che voglio stampare
    - i parametri espliciti sono quelli tra le parentesi
- Altri metodi no: tutte le info necessarie sono memorizzate nell'oggetto corrispondente, il parametro implicito
    [java]
        int n = greeting.length();
    [/java]
    - qui greeting è il parametro implicito: length viene calcolata sui dati contenuti nella variabile oggetto che invoca il metodo e perciò restituirà la lunghezza di "Hello, World!"

# Un metodo con parametri espliciti e parametro implicito
    [java]
        public String replace(String oldStr, String newStr);
    [/java]
    - Il metodo replace della classe String riceve due parametri espliciti, entrambi stringhe, e cerca nella stringa descritta dal parametro implicito le occorrenze del primo parametro per sostituirle con il secondo. Restituisce la stringa ottenuta in un altro oggetto, senza modificare la stringa associata al parametro implicito.
        - questa è una caratteristica di tutti i metodi di String, ma non è vera per tutte le classi. Esistono metodi, detti modificatori, che modificano i dati interni alla classe.
    [java]
        river.replace("issipp", "our");
    [/java]
        - due parametri espliciti: le stringhe "issipp" e "our"
        - un parametro implicito: l'oggetto river (la stringa "Mississippi")
        - un valore restituito: la stringa "Missouri"
    [java]
        System.out.println(river.replace("issipp", "our")); // Stampa Missouri
        System.out.println(river); // Stampa Mississippi
    [/java]

# Definizioni di metodi: firma
    ?- come faccio a sapere se il metodo che voglio utilizzare ha dei parametri espliciti, di che tipo sono, e in che ordine li devo specificare?
    ?- come faccio a sapere che tipo di dato restituisce un metodo?

    Queste informazioni sono contenute nella documentazione della classe, in quella che si chiama firma del metodo

    [java]
        public String replace(String target, String replace); // String = tipo restituito | replace = nome metodo | (...,  ...) = Parametri espliciti
        public void println(String output);
        public String replace(String target, String replace);
    [/java]

    - La definizione di un metodo inizia con la sua intestazione (firma, signature):
        - uno specificatore di acecsso
            - indica quli altri metodi possono invocare il metodo 
                - un metodo "public" può essere invocato da qualsiasi altro metodo di qualsiasi altra classe
                - un metodo può essere anche private
        - il tipo di dati restituito dal metodo (String, void, int, ...)
        - il nome (identificatore) del metodo (println, replace, ...)
        - un elencto di parametri espliciti, eventualmente vuoto, tra parentesi tonde
            - di ogni parametro si indica il tipo ed il nome
            - più parametri sono separati da una virgola
    - La dichiarazione di un metodo specifrica il tipo di dati restituito al termine della sua invocazione 
    - Se un metodo non restituisce nessun valore si dichiara il tipo speciale void
        - il valore restituito, se assegnato, deve essere assegnato ad un tipo di dati corrispondente

// ---------------------------------------------------------------------------------------------------------------------------------------------------------

# Variabili oggetto
    Una "variabile oggetto" conserva non l'oggetto stesso, ma informazioni sulla sua posizione nella memoria del computer. 
        * è detta anche "riferimento" o "puntatore"
    Come già visto per oggetti della classe String, per definire una variabile oggetto si indica il nome della classe ai cui oggetti farà riferimento la variabile, seguito dal nome della variabile stessa
    [java]
        NomeClasse nomeOggetto;
    [/java]

    ## Costruire oggetti: l'operatore NEW
    - A differenza di quanto visto per gli oggetti della classe String, in generale per creare un nuovo oggetto di una classe si usa l'operatore "new" seguito dal nome della classe e da una coppia di parentesi tonde.
    [java]
        new NomeClasse(parametri);

        // Questa inizializzazione è valida anche per String, ma meno usata.
        String river = "Mississippi";
        String river = new String("Mississippi");
    [/java]
    - L'operatore "new" crea un nuovo oggetto e ne restituisce un riferimento, che può essere assegnato a una variabile oggetto del tipo appropriato.
    [java]
        NomeClasse nomeVar = new NomeClasse(parametri);
    [/java]

    ## Esempio: la classe Rectangle
    - Un rettangolo è descritto dalle coordinate (x,y) del suo vertice in alto a sinistra, e da larghezza e altezza
        - per creare un rettangolo bisogna
            - specificare x, y, width, height
            - invocare l'operatore New e il costruttore con i parametri richiesti
            - assegnare il rettangolo appena creato ad una variabile oggetto
            [java]
                Rectangle box = new Rectangle(5,10,20,30);
            [/java]

    ## Costruttori vs Metodi
    - Il processo di creazione di un nuovo oggetto è detto costruzione e ciò che segue l'operatore new è detto "costruttore"
    -! Un costruttore NON è un metodo
        - Ci assomiglia perché il nome è seguito dalle parentesi e pu avere dei parametri espliciti
        - il suo nome è uguale a quello della classe
            - però inizia con la maiuscola
        - non viene invocato da un parametro implicito
            - utilizzabile solo con "new"
        [java]
            Rectangle box = new Rectangle(5,10,20,30); // Corretto
            box.Rectangle(20,35,20,30)                 // ERRORE
        [/java]
            - ora box contiene un riferimento ad un oggetto che si trova in posizione x=20, y=35 e ha dimensioni di 20x20
    - Per vedere che metodi ha a disposizione un oggetto istanza della classe Rectangle basta cercare la classe nella documentazione java



[2023-11-07]
# Alternative multiple

    ## Sequenze di confronti
        - se si hanno più di due alternative, si usa una sequenza di confronti
        [java]
            if (richter >= 8)
                System.out.println("Terremoto molto forte");
            else if (richter >= 6)
                System.out.println("Terremoto forte");
            else if (richter >= 4)
                System.out.println("Terremoto medio");
            else if (richter >= 2)
                System.out.println("Terremoto debole");
            else if (richter >= 0)
                System.out.println("Terremoto molto debole");
            else
                System.out.println("Numeri negativi non validi");
        [/java]
        - l'ordine e la sequenza sono importanti
        - se si fanno confronti di tipo "maggiore di" si devono prima scrivere i valori più alti, e viceversa.
        - se non si rendono mutuamente esclusive le alternative, usando le clasuole "else", non funziona

    ## Diramazioni annidate
        - Caso di studio:
            Calcoliamo le tasse secondo le aliquote del sistema federale americano nel 2008
            [java]
                public class TaxReturn
                {
                    // variabili d'istanza
                    private int status;
                    private double income;

                    // costanti
                    public static final int SINGLE = 1;
                    public static final int MARRIED = 2;

                    public static final double RATE1 = 0.10;
                    public static final double RATE2 = 0.25;

                    public static final double SINGLE_LIMIT = 32000;
                    public static final double MARRIED_LIMIT = 64000;


                    public TaxReturn(int aStatus, double anIncome)
                    {
                        status = aStatus; income = anIncome;
                    }
                }
            [/java]
            (piccola prova fatta in TaxCalculator.java)
    ## il problema dell'else sospeso
        - nell'esempio seguente i livelli di rientro suggeriscono che la clausola else si riferisca al primo enunciato if
        [java]
            if (richter >=0)
                if (richter <= 4)
                    ...
            else                     // non funziona!!
                ...
        [/java]
        - compilatore ignora i rientri
            - risultati ottenuti errari
            - regola sintattica è che ! una clausola else appartiene sempre all'eunciato if più vicino!
        - per ottenere il risultato voluto, bisogna "nascondere" il secondo enunciato if all'interno di un blocco di enunciati, inserendo una coppia di parentesi graffe.
        [java]
            if (richter >=0)
            {

                if (richter <= 4)
                {
                    ...
                }
            }
            else
            {
                ...
            }
        [/java]
    
    ## Visibilità delle variabili
        - se il valore finale di una variabile usata nel corpo di un enunciato if/else deve essere visibile al di fuori del corpo, bisogna definirlo PRIMA dell'enunciato if/else
        - poiché una variabile definita nel corpo di un enunciato if/else non è più definita dopo di esso, è possibile usare di nuovo lo stesso nome successivamente nel codice (ma fare molta attenzione
        
        [java]
            double b = ...;
            if (b < 10)
            {
                double c = ...;
                // modifica b e c ...
            }
            // qui b è visibile, ma c no
        [/java]

    (esercizio in classe, PunteggioGiocatori.java)

# Conversione di stringhe in Numeri
    - A volte si ha una stringa che continene un valore numerico e si vuole assegnare tale valore a una variabile di tipo numerico, per poi elaborarlo
    [java]
        String password = "md50";
        String ageString = password.substring(2);
        // ageString contiene "50"
        // NON FUNZIONA
        int age = ageString;
    [/java]
    - il compilatore segnala l'errore semantico perché non si può convertire automaticamente una stringa in un numero, dato che non vi è certezza che il suo contenuto rappresenti un valore numerico.
    - la conversione corretta si ottiene invocando il metodo statico "parseInt" della classe "Integer"
    [java]
        int age = Integer.parseInt(ageString);
        // age contiene il numero 50
    [/java]
    - la conevrsione di un numero in viggola mobile si otteiene, analogamente, invocando il metodo statico "parseDouble" della classe "Double".
    [java]
        String numberString = "34.3";
        double number = Double.parseDouble(numberString);
        // number contiene il numero 34.3
    [/java]
    - NON viene usata la localizzazione, quindi la stringa deve contenere sempre il punto come separatore decimale.
    - oppure usare notazione scientifica.
    - Cosa succede se la stringa passata come argomento non contiene un numero? 
    - i metodi Integer.parseInt e Double.parseDouble lanciano un'eccezione di tipo "NumberFormatException" e il programma termina segnalando l'errore
    - Il meccaniscmo generale di segnalazione di errori in Java consiste nel fare un throw di un'eccezione

# Espressioni booleane
    - Ogni espressione ha un valore
        - x + 10 espressione aritmetica, valore numerico
        - x < 10 espressione relazionale, valore booleano
    - un'espressione relazionale ha un valore vero o falso (true or false)
    - i valore true e false non sono numeri, ne oggetti, ne classi: appartengono ad un tipo di dati diverso, detto booleano.
    - è un tipo fondamentale in java, come quelli numerici
    - i tipi di dati boolean, come tutti gli altri tipi di dati, consente la definizione di variabili e l'assegnazione di valori
        boolean a = true;
    - a volte è comodo utilizzare variabili booleane per memorizzare valori di passaggi intermedi in cui è opportuno scomporre verifiche troppo complesse.
    - altre volte l'uso di una variabile booleana rende più leggibile il codice
    - spesso le variabili booleane vengono chiamate flags, perché possono assumere soltanto due valori, cioè trovarsi in due soli stati possibili

        ## Operatori booleani
        - Gli operatori booleani o logici servono a svolgere operazioni su valori booleani
        [java]
            if (x > 10 && x < 20) // esegue se x è maggiore di 10 e minore di 20
        [/java]
        - l'operatore "&&" (and) combina due o più combinazioni in una sola, che risulta vera se e solo se tutte sono vere
        - l'operatore "||" (or) combina due o più condizioni in una sola, che risulta vera se e solo se almeno una è vera
        - l'operatore "!" (not) inverte il valore di un'espressione booleana
        - più operatori booleani possono essere usati in un'unica espressione
            [java]
            if ((x > 10 && x < 20) || x > 30) {...}
            [/java]
        - la valutazione di un'espressione con operatori booleani viene effettuata con uan strategia detta "cortocircuito"
            - la valutazione dell'espressione termina appena è possibile decidere il risultato
        - in un'espressione booleana con più operatori, la valutazione viene fatta da sinistra a destra, dando la precedenza all'operatore not, poi all'operatore and, infine all'operatore or
        - l'ordine di valutazione può comunque essere alterato dalle parentesi tonde
        [java]
            if (!(x<0 || x>10)){...}
            // esegue se x è compreso tra 0 e 10, estremi inclusi
            if (!x<0 || x>10){...}
            // esegue se x è maggiore o uguale a 0
        [/java]



[2023-11-08]
    ## Leggi di De Morgan
        - Due leggi per semplificare espressioni logiche
            - criterio per convertire un'espressione "negata" in un'espressione "affermata"
            1. Legge "!(A && B) è uguale a !A || !B"
            2. Legge "!(A !! B) è uguale a !A && !B"
            - gli operatori not vengono spostati sulle singole variabili
            - gli operatori AND e OR vengono scambiati
            [java]
                if (!(x < 0 || x > 10)) {}
                if ( x>=0 && x<=10) {}
            [/java]

    ## Iterazioni (while loops)
        - L'enunciato "while" consente la realizzazione di programmi che devono "eseguire ripetutamente" una serie di azioni "finché" è verificata una condizione 
        - Sintassi:
            [java]
                while (condizione)
                {
                    enunciato
                }
            [/java]
        - Scopo: eseguire un enunciato finché la condizione è verificata
        - Nota: il corpo del ciclo while può essere un enunciato qualsiasi, quindi anche un blocco di enunciati
        - Esistono errori logici che impediscono la terminazione di un ciclo, generando un ciclo infinito
        - l'esecuzione del seguente programma continua ininterrottamente
        [java]
            int year = 0;
            while (year < 20)
            {
                double interest 0 balance * rate / 100;
                balance = balance + interest;

                // qui manca year++, quindi il ciclo continua infinitamente
            }
        [/java]
        - in questo caso bisogna arrestare il programma con un comando del sistema operativo o addirittura riavviare il computer

    ## Cicli for
        - generalmente, molti cicli hanno la seguente forma
            [java]

                i = inizio;
                while (i < fine)
                {
                    enunciati();
                    i++;
                }

            [/java]
        - per comodità esiste il ciclo "for" equivalente
            [java]

                for (i = inizio; i < fine; i++)
                {
                    enunciati();
                }

            [/java]
        - non è necessario che l'incremento sia di una sola unità, ne che sia positivo, ne che sia intero.
        - Sintassi:
            [java]

                for (inizializzazione; condizione; aggiornamento)
                {
                    enunciati
                }

            [/java]
        - Scopo: eseguire un'inizializzazione, poi ripetere l'esecuzione di un enunciato ed effettuare un aggiornamento finché la condizione è vera. 
        - Nota: l'inizializzazione può contenere la definizione di una variabile, che sarà visibile soltanto all'interno del corpo del ciclo
            [java]

                for (int y = 1; y <= 10; y++)
                {
                    ...
                }
                // qui y non è più definita

            [/java]
        


[2023-11-10]
    ## Ciclo e mezzo
    - un ciclo del tipo
        - fai qualcosa, verifica una condizione, fai qualcos'altro e ripeti il ciclo se la condizione era vera
    - non ha una struttura di controllo predenfinita in Java e dev'essere realizzata con un "trucco", come quello di usare una variabile booleana
    - una struttura di questo tipo si chiama anche "ciclo e mezzo" o ciclo ridondante
    - una situazione tipica è quella in cui l'utente deve inserire un insieme di valori, la cui dimensione non è predenfinita
        - si realizza un ciclo while, dal quale si esce soltanto quando si verifica la condizione all'interno del ciclo

    ## Ciclo "do"
    - capita spesso di dover eseguire il corpo di un ciclo almeno una volta, per poi ripeterne l'esecuzione se è verificata una particolare condizione
    - per esempio, si vuole leggere un valore in ingresso, ed eventualmente rileggerlo finché non viene introdotto un valore valido
        [java]
            // si può usare un ciclo while "innaturale"
            // si usa un'inizializzazione "ingiustificata"
            double rate = 0;
            while (rate <= 0)
            {
                System.out.println("Inserire il tasso: ");
                rate = console.nextDouble();
            }

            // oppure si può ricopiare il corpo del ciclo (o una sua parte) prina del ciclo stesso
            System.out.println("Inserire il tasso: ");
            double rate = console.nextDouble();
            while (rate <= 0)
            {
                System.out.println("Inserire il tasso: ");
                rate = console.nextDouble();
            }

            // ma per comodità e chiarezza esiste il ciclo do
            do
            {
                System.out.println("Inserire il tasso: ");
                rate = console.nextDouble();
            } while (rate <= 0); // qui certamente a rate è stato assegnato un valore
        [/java]

    ## variabile non inizializzata
    [java]
        // ecco un caso in cui è ammessa la dichiarazione di variabile senza inizializzazione
        // meglio fare così piuttosto di inizializarla ad una valore immediato

        double rate;
        do
        {
            System.out.println("Inserire il tasso: ");
            rate = console.nextDouble();
        } while (rate <= 0);
    [/java]
    - inizializzando ad un valore immediato da due problemi
        1) al termine dell'esecuzione del ciclo do, la variabile rate non è più visibile perché è definita all'interno del suo corpo
            - quindi il valore letto da tastiera non è utilizzabile
        2) in realtà, rate non è visible nemmeno nel punto in cui si valuta la condizione di uscita dal ciclo (rate <= 0), sempre perché è definita all'interno del corpo, quindi si ha errore di sintassi

    ## l'enunciato BREAK
    - L'enunciato break si può usare per terminare un ciclo
        - l'itereazione in corso NON viene completat, il ciclo termina "bruscamente"
        - se la condizione di uscita dal ciclo può essere erificata in un punto INTERNO al ciclo, si realizza un ciclo infinito while(true), dal quale si esce soltanto quando si verifica la condizione all'interno del ciclo. 
        [java]
        while (true)
            {
                ...
                if (...)
                {
                    break;
                }
                ...
            }
        [/java]
    - nel caso di cicli annidati, l'enunciato break provoca la terminazione del ciclo più interno tra quelli in cui si trova l'enunciato stesso
        [java]
            int i=0, j=0;
            while (true)
            {
                System.out.println("i= " + i);
                while (true)
                {
                    if (j==5) 
                    {
                        break;
                        System.out.println("j= " + j);
                        j++;
                        ...
                    }
                    i++;
                    if (i==3)
                    {
                        break;
                    }
                }
            }
        [/java]
    - l'esecuzione dell'enunciato break deve essere condizionata
        - in caso contrario, la porzione di corpo del ciclo che si trova dopo l'enunciato break non viene MAI eseguita
        - è certamente un errore logico, segnalato dal compilatore come "unreachable statement" dal flusso d'esecuzione
    - l'enunciato break NON è necessario, si può sempre scrivere codice equivalente

    ## enunciato Cotinue
    - esiste anche l'enunciato "continue" e può essere usato all'interno dei cicli
        - provoca la terminazione dell'iterazione corrente e il passaggio all'iterazione successiva

    ## l'utilizzo di break e continue
    - l'uso di break e continue è non necessario e sconsigliabile perché contribuisce a creare "spaghetti code", ovvero rappresentato da diagrammi di flusso pieni di linee, difficili da leggere e comprendere.

    ## Enunciato switch
    - una sequenza che confronti un'unica variabile intera con diverse alternative costanti può essere realizzata con un enunciato switch
    - vantaggio: non bisogna ripetere il nome della variabile da confrontare
    - svantaggio: si può usare solo se la variabile da confrontare è intera (byte, short, char, int) oppure una string (da java 7)
    - svantaggio: non si può usare se uno dei valori da confrontare non è costante
    - svantaggio: ogni case deve terminare on un enunciato break, altrimenti viene eseguito anche il corpo del case succcessivo


[2023-11-15]
# ARRAY
    Lo strumento messo a disposizione dal linguaggio Java (e in molti altri linguaggi di programmazione) per memorizzare una sequenza di dati si chiama "array"
    In Java, un array è un oggetto che rappresenta una sequenza posizionale di dati omogenei, che vengono detti elementi o componenti dell'array

    - Costruire un array:
        - un array in java è un oggetto
            - come ogni oggetto, deve essere costruito con l'operatore new, dichiarando il tipo di dati che potrà contenere
            [java]
            new double[10];
            [/java]
        - nella costruzione il tipo di dati è seguito da una coppia di parentesi quadre che contiene la dimensione dell'array, cioè il numero di elementi che potrà contenere
        - in Java, le parentesi quadre si usano SOLO per gli array
        - il tipo di dati di un array può essere qualsiasi tipo di dati valido in java
            - uno dei tipi di dati fondamentali o una classe
            - potremo avere quindi array di numeri interi, di numeri in virgola mobile, di stringhe, di conti bancari..
        - si dice anche che l'array è costituito da celle o posizioni, nelle quali sono memorizzati i suoi elementi
            - le posizioni sono identificate da numeri interi non negativi
            - esiste il dato in prima posizione (posizione 0), quello in seconda posizione (posizione 1), ecc...
            - quindi l'array NON rappresenta un insieme matematico, anhe perché i dati presenti nell'array possono essere replicati in diverse posizioni

    - riferimento a un array:
        - come avviene dopo la costruzione di qualunque oggetto, l'operatore new restituisce un riferimento all'array appena creato, che può essere memorizzato in una variabile oggetto dello stesso tipo
        [java]
        double[] values = new double[10];

        // si può fare anche in due passi
        double[] values;
        ... 
        values  = new double[10];
        [/java]
        - ATTENZIONE: nella definizione della variabile oggetto devono essere presenti le parentesi quadre, ma NON dev'essere indicata la dimesione dell'array; la variabile potrà riferirsi solo ad array di quel tipo, ma di qualunque dimensione
            - non esiste, quindi, il tipo di dato "array di dieci double", bensì il tipo di dato "array di double"
        [java]
        double[] x = new double[6];
        [/java]
            - una variabile x che si riferisce a un array è una variabile oggetto che contiene un riferimento all'oggetto array

    - utilizzare un array:
        - al momento della costruzione, tutti gli elementi dell'array vengono inizializzati a una valore, seguendo le stesse regole viste per le variabili di esemplare prive di inizializzazione esplicita.
        [java]
        double[] values = new double[10];
        // tutti gli elementi sono inizializzati a 0 in questo caso
        [/java]
        - si accede al contenuto di una cella dell'array indicando tra parentesi la posizione voluta
            - accesso al contenuto della posizione i dell'array values:
                [java]
                values[i];
                [/java]
        - si può leggere il contenuto di una cella dell'array, per usarlo in un'espressione
        [java]
        double doubleVar = 5 + values[3];
        [/java]
        - la stessa sintassi si usa per scrivere un valore in una cella dell'array, ponendola nella parte sinistra di un enunciato di assegnazione
            [java]
            values[9] = 3.4 + Math.sqrt(2);
            [/java]
            [java]
            double[] values = new double[10];
            double oneValue = values[3]; // vale 0
            values[9] = 3.4;
            [/java]
        - il numero utilizzato per accedere a un particolare elemento dell'array si chiama indicare
        - l'indice può assumere un valore compreso tra 0 (incluso) e la dimensione dell'array (esclusa), cioè segue le stess convenzioni viste per le posizioni dei caratteri in una stringa
            - il primo elemento ha indice 0
            - l'ultimo elemento ha indice (dimensione - 1)
        - a tutti gli effetti sintattici e semantici, un elemento di un array equivale a una singola variabile dello stesso tipo
            - values[3] è, quindi, una variabile di tipo double
        - l'indice di un elemento di un array può, più in generale, essere un'espressione di tipo int
            [java]
            double[] values = new double[10];
            int a = 4;
            values[a + 2] = 3.2 // modifica il settimo elemento (parto da indice 0)
            [/java]
        - se si accede a un elemento dell'array usando un indice sbagliato, l'ambiente di esecuzione lancia un'ecceszione di tipo "ArrayIndexOutOfBoundsException"

    - struttura di dati ad accesso casuale: il tempo di accesso (in lettura o scrittura) a uno dei suoi elementi non deve dipendere dal valore dell'indice associato a tale elemento.

    - la dimensione di un array: 
        - un array non ha metodi pubblici, ne statici, ne di esemplare
        - l'unico elemento pubblico di un oggetto di tipo array è la sua dimensione, a cui si accede attraverso la sua variabile pubblica di esemplare length (attenzione, non è un metodo)
        - una variabile pubblica di esemplare sembrerebbe una violazione delle regole
        - in realtà, length è una variabile pubblica ma è final, quindi non può essere modificat, può soltanto essere ispezionata.
            - questo paradigma è, in generale, considerato accettabile nell'OPP
                [java]
                double[] values = new double[10];
                values.length = 15; // errore in compilazione 

                // in alternativa si sarebbe potuto fornire un metodo pubblico per accedere alla variabile privata
                double[] values = new double[10];
                int a = values.getLength(); // non è così!
                // la soluzione progettuale scelta è meno elegante ma fornisce lo stesso livello di protezione dell'informazione ed è più veloce in esecuzione
                [/java]

        ## argomenti sulla riga di comando 
        [java]
            public static void main(String[] args)
        [/java]
        - Quando si esegue un programma Java, è possibile fornire dei parametri dopo il nome della classe che contiene il metodo main 
        - Tali parametri vengono letti dall'interprete Java e trasformati in un array di stringhe che costituisce il parametro del metodo main

        [java]
            public class Program
            {
                public static void main(String[] args)
                {
                    System.out.println(args.length);
                    System.out.println(args[1]);
                }   // qui sotto l'output del programma, se viene eseguito con la riga di comando vista sopra
            }
        [/java]

        ## Copiare o clonare un array
        - una variabile che si riferisce a un array è una variabile oggetto che contiene un riferimento all'oggetto array. Copiando il contenuto della variabile in un'altra non si copia l'array, ma si ottiene un altro riferimento allo stesso oggetto array.
        - se si vuole clonare un array, bisogna:
            1) creare un nuovo array dello stesso tipo e con la stessa dimensione
            2) copiare ogni elemento del primo array nel corrispondente elemento del secondo array
            [java]
                double[] values = new double[10];
                // inseriamo i dati nell'array
                ...
                double[] otherValues = new double[values.length];
                for (int i = 0; i < values.length; i++)
                {
                    otherValues[i] = values[i];
                }
            [/java]
        - invece di usare un ciclo, è possibile invocare il metodo statico "arraycopy" della classe System.
        - il metodo "System.arraycopy" consente, più in generale, di copiare una porzione di un array in un altro array
            - anche l'array di destinazione (quello in cui si copiano i dati) deve già esistere e deve essere grande a sufficienza

        ## Dimemsione fisica vs dimensione logica
        - Dimensione fisica:
            - values.length è il numero di valori memorizzabili ed è la dimensione fisica dell'array
        - Dimensione logica:
            - valuesSize è il numero di valori memorizzati ed è la dimensione logica dell'array

        ## Array riempiti solo in parte
        - Si dice che un array utilizzato in questo modo è "riempito solo in parte", anche se sarebbe meglio dire "riempito in una sua porzione iniziale" (eventualmente vuota o eventualmente coincidente con l'intero array).
        - valuesSize è una variabile esterna all'array, non esistono oggetti primitivi di tipo "array riempito solo in parte".
        - L'array riempito solo in parte è, quindi, semplicemente una modalità di utilizzo di un normale array, a cui viene associata, dal punto di vista logico (ma non strutturale), una variabile di tipo int. 

        ## Cambiare dimensione a un array
        - Non si può aumentare o diminuire la dimensione di un array.
        - Si può creare un nuovo array più grande di quello "pieno"
            - ad esempio: il doppio, ma potrebbe bastare un elemento in più
            - copiarne il contenuto
            - "abbandonare il vecchio array, usando poi quello nuovo
        - si parla di array dinamico, sottointendendo che in realtà si tratta di una gestione dinamica dell'array:
            - non può esserci ambiguità perché in Java non esistono array dinamici, cioè di dimensione modificabile
        - si dice anche che si ridimensione l'array, di nuovo senza ambiguità

            [java]
                if (valuesSize == values.length) // è pieno
                {
                    double[] newValues = new double[values.length * 2];
                    for (int i = 0; i < values.length; i++)
                    {
                        newValues[i] = values[i];
                    }
                    values = newValues;
                    // valuesSize ovviamente non cambia
                    // values non punta più al vecchio
                    // array che viene abbandonato.
                }
            [/java]

        - possiamo progettare un metodo di utilità che restituisca un array "ingrandito" a partire da quello che viene fornito

            [java]
                public class ArrayUtil
                {
                    public static double[] resize(double[] oldArray, int newLength)
                    {
                        if (newLength < oldArray.length)
                        {
                            // gestire la situazione come più opportuno
                        }
                        
                        double[] newArray = new double[newLength];
                        for (int i = 0; i < oldArray.length; i++)
                        {
                            newArray[i] = oldArray[i];
                        }

                        return newArray;
                    } 
                    // la "coda" del nuovo array rimane riempita con i valori predenfiniti

                    public static void main(String[] args)
                    {
                        double[] values = {1, 2.3, 4.5};
                        values = ArrayUtil.resize(values, 5);
                        values[4] = 5.2;
                        
                        
                        // lo stesso metodo può essere usato per CLONARE un intero array; in seguito, è consentito utilizzare sia iul nuovo sia il vecchio

                        double[] values = {1, 2.3, 4.5};
                        double[] newV = ArrayUtil.resize(values, values.length);
                        values[2] = 5.2;

                    }
                }
            [/java]

        ## Garbage Collector
        - la JVM provvede a effettuare automaticamente la gestione della memoria (garbage collection) durante l'esecuzione di un programma
        - gli oggetti che non hanno più un riferimento nel programma vengono considerati memoria libera. 

            ### Allocazione della memoria in Java
            - Durante l'esecuzione dei metodi di un programma vengono creati dinamicamente oggetti (allocazione dinamica) usando lo speciale operatore new:
                - BankAccount acct = new BankAccount();
                - crea dinamicamente un oggetto di classe BankAccount
            - Per l'allocazione dinamica di oggetti Java usa un'area di memoria denominata Java Heap.

        ## Array riempito in parte come parametro
        - un metodo che voglia elaborare un array riempito solo in parte deve dichairare due parametri..
            - 1. l'Array
            - 2. la sua dimensione logica, perché quest'ultima non può essere dedotta ispezionando l'array, come invece avviene per la dimensione fisica
            - NB: se passo come parametro v.length elaboro array pieni

# ARRAY BIDIMENSIONALI E MULTIDIMENSIONALI
    - problema:
        - stampare una tabella con i valor idelle potenze x^y, tra 1 e 4 per ogni valore di y tra 1 e 5

            1       1      1       1       1
            2       4      8      16      32
            3       9     27      81     243
            4      16     64     256    1024

        - una struttura di questo tipo, con dati organizzati in righe e colonne, si dice "MATRICE" o array bidimensionale
        - un elemento all'interno di una matrice p identificato da una coppia (ordinanta) di indici
            - un indice di riga
            - un indice di colonna
        - in Java esistono gli array bidimensionali e, in generale, multidimensionali
            ! sempre di dati omogenei
        - dichiarazione di un array bidimensionale con elementi di tipo int
            [java]
                int[][] powers;
            [/java]

        - costruzione di array bidimensionale di tipo int con 4 righe e 5 colonne
            [java]
                new int[4][5];
            [/java]

        - Assegnazione di un riferimento ad array bidimensionale
            [java]
                powers = new int[4][5];
            [/java]

        - Accesso a un elemento di un array bidimensionale
            [java]
                powers[2][3] = 2;
                int x = powers[0][1] + 5;
            [/java]
            
        - Ciascun indice deve essere:
            - di tipo int
            - non negativo
            - minore della dimensione corrispondente
        - per conoscere il valore delle due dimensioni
            - la prima dimensione è "powers.length;"
            - la seconda dimensione è "powers[0].length;" // perché in realtà un array bidimensionale è un array di array
        - in un array tridimensionale (double[][][] powers), la terza dimensione è, analogamente "powers[0][0].length;"

        - ESEMPIO: TableOfPowers.java

# SEMPLICI ALGORITMI SU ARRAY
    ! GENERO FILE CHIAMATO: ArrayUtil.java

    ## Numeri Casuali
    - La classe Math mette a disposizione il metodo statico random() per generare sequenze di numeri pseudo-casuali
    - Ogni invocazione del metodo restituisce un numero reale pseudo-casuale nell'intervalloa [0, 1[
        [java]
            double x = Math.random();
        [/java]
    - per ottenere, ad esempio, numeri interi casuali compresi nell'intervallo [a, b], basta fare un po' di calcoli...
        [java]
            int n = (int)(a + (1+b-a)*Math.random());
        [/java]
    - ESEMPIO: AverageDice.java

    - usando random scriviamo nella classe ArrayUtil un metodo che genera array di numeri interi casuali, ciascuno dei quali ha un valore compreso tra 0 e n.

    ## ELIMINARE UN ELEMENTO
    - L'eliminazione di un elemento da un array richiede due algoritmi diversi
        - se l'ordine degli elementi non è importante, è sufficiente spostare l'ultimo elemento nell'indice da eliminare e
            - ridimensionare l'array se uso array riempiti completamente
            - decrementare la dimensione logica se uso array riempiti parzialmente
        - se l'ordine degli elementi è importante, è necessario spostare tutti gli elementi successivi di un indice verso sinistra
        [java]
            double[] values = {1, 2.3, 4.5, 5.6};
            int vSize = 4; // array pieno, dim logica = dim fisica
            int iIndexToRemove = 1;
            for (int i = iIndexToRemove; i < values.length - 1; i++)
            {
                values[i] = values[i + 1];
            }
            vSize--;
        [/java]

    ## INSERIRE UN ELEMENTO
    - Per inserire un elemento in un array nella posizione voluta, se questa non è la prima posizione libera, bisogna "fargli spazio"
        - tutti gli elementi il cui indice è maggiore dell'indice della posizione voluta devono essere spostati nella posizioen con indice immediatamente superiore, a partire dall'ultimo elemento dell'array
        [java]
            double[] values = {1, 2.3, 4.5, 5.6};
            values = resize(values, values.length + 1);

            int iIndex = 2;
            for (int i = values.length - 1; i > iIndex; i--)
            {
                values[i] = values[i - 1];
            }
            values[iIndex] = 5.4;
            vSize++;
        [/java]
    # Ricerca di un valore in un array
        [java]
            // Declare and initialize an array of doubles with a size of 100
            double[] v = new double[100];

            // Declare and initialize a variable to hold the number of elements in the array
            int vSize = 0;

            // Declare a variable to hold the target value to be searched for in the array
            double target;

            // Declare and initialize a boolean variable to indicate whether the target value is found in the array
            boolean found = false;

            // Read the data. At the end, vSize contains the number of elements and target contains the value to be searched for

            // Iterate over the elements in the array
            for (int i = 0; i < vSize; i++)
            {
                // Check if the current element is equal to the target value
                if (v[i] == target)
                {
                    // If it is, set found to true and exit the loop
                    found = true;
                    break;
                }
            }

            // Check if the target value was found in the array
            if(found)
            {
                // If it was, print a message indicating that it was found
                System.out.println("Trovato");
            }
            else
            {
                // If it wasn't, print a message indicating that it was not found
                System.out.println("Non trovato");
            }

        [/java]

# Varianti per verificare la presenza di uno specifico valore 
    - l'algoritmo può essere realizzato in diverse varianti e inserito in un metodo che riceve il valroe da cercare e l'array in cui cercare
        - un valore boolean: successo/insuccesso della ricerca
        - un valore int: posizione dell'elemento trovato, -1 se non trovato
        - un array di int: posizioni di tutti gli elementi trovati, array vuoto se non trovato


# GESTIONE DI CONTENUTI CONDIVISI IN UNA CLASSE
    ## Metodi ausiliari
    - I metodi ausiliari aiutano a strutturare meglio il codice svolgendo un sottoinsieme di istruzioni che possono venire invocate da altri metodi della classe, inclusi i metodi di esemplare.
    
    ## Metodi statici o di classe
    - Sono metodi che non vengono invocati con un oggetto come parametro implicito
    - Es: i metodi della classe Math
        - I numeri non sono oggetti e non posso utilizzarli per invocare metodi
        - Math.sqrt(2);
            - Math non crea in oggetto ma dice solo dove si trova il metodo
    
    ## Invocazione di metodi ausiliari statici
    - Per invocare un metodo statico presente nella stessa classe non è necessario specificare il nome della classe
    - Se il metodo statico si trova in un'altra classe bisogna specificare il nome della classe
    [java]
        public class A
        {
            public static void main(String[] args)
            {
                B.faiQualcosa(); // fa parte della classe B
                stampa();        // fa parte della classe A
            }

            public static void stampa()
            {
                System.out.println("Ciao");
            }
        }
        public class B
        {
            public static void faiQualcosa()
            {
                ...
            }
        }
    [/java]

    ## Invocazione di metodi ausiliari non statici
    - Anche un metodo di esemplare può invoareu n altro metodo di esemplare della stessa classe senza specificare una variabile oggetto.
    - In questo caso, il metodo invocato viene eseguito sullo stesso oggetto su cui è stato invocato il metodo che lo invoca
    - Esempio: associo ad ogni deposito una commissione (che di fatto è un prelievo)
    [java]
        public void deposit(double amount)
        {
            withdraw(2); // evito di duplicare il codice di withdraw
            balance += amount;
        }

        // in questo caso, come per le variabili, viene usato implicitamente this, come se fosse
        public void deposit(double amount)
        {
            this.withdraw(2);
            this.balance += amount;
        }
    [/java]
    - il parametro implicito con cui è stato invocato deposit diventa "automaticamente" il parametro implicito con cui viene invocato withdraw.

    ## Metodi di esemplare ausiliari
    - aggiungiamo un contatore di operazioni effettuate
    [java]
        public class BankAccount
        {
            private double dBalance;
            private int iNumberOfOperations;

            public void deposit(double amount)
            {
                balance += amount;
                iNumberOfOperations++;
            }

            public void withdraw(double amount)
            {
                balance -= amount;
                iNumberOfOperations++;
            }

            public double getBalance()
            {
                return balance;
            }

            public int getNumberOfOperations()
            {
                return numberOfOperations;
            }
        }
    [/java]
    - idealmente sarebbe meglio evitare codice duplicato e creare metodi ausiliari 
    [java]
        public class BankAccount
        {
            private double dBalance;
            private int iNumberOfOperations;

            private void recordOperation()
            {
                numberOfOperations++;
                balance -= 2.5; // commissione
            }

            public void deposit(double amount)
            {
                balance += amount;
                recordOperation();
            }

            public void withdraw(double amount)
            {
                balance -= amount;
                recordOperation();
            }

            public double getBalance()
            {
                return balance;
            }
        }
    [/java]

# VARIABILI STATICHE
    - Una variabile static (detta variabile di classe) è condivisa da tutti gli oggetti della classe e ne esiste un'unica copia.
        - non si trova all'interno degli esemplari della classe, ma in una zona di memoria riservata alla classe
    -! osserviamo che le variabili statiche non dovrebbero (da un punto di vista logico) essere inizializzate nei Costruttori
        - il loro valore verrebbe inizializzato di nuovo ogni volta che si costruisce un oggetto, perdendo il vantaggio di avere una variabile condivisa!
    - Bisogna inizializzarle quando si dichiarono
        [java] private static int iLastAssignedNumber = 0; [/java]
        - sappiamo che questa sintassi si può usare anche per le variabili di esemplare, anziché usare un costruttore, ma non è una buona pratica di programmazione
    - Nella programmazione a oggetti, l'utilizzo di variabili statiche deve essere limitato, perché
        - metodi che leggono variabili statiche e agiscono di conseguenza hanno un comportamento che non dipende soltanto dai loro parametri (implicito ed espliciti), quindi sono più esposti ai cosiddetti "effetti collaterali", cioè effetti più difficili da prevedere correttamente
    - in  ogni caso, le variabili statiche devono essere private come quelle di esemplare, per evitare accessi indesiderati
        - se iLastAssignedNumber fosse public, vi si potrebbe accedere (in lettura o in scrittura) anche da un metodo esterno alla classe usando la sintassi BanckAccount.iLastAssignedNumber, cioè usando il nome della classe.
    - è invece pratica comune (senza controindicazioni) usare costanti statiche, come nella classe Math
    - Tali costanti sono di norma public e per accedere al loro valore si usa il nome della classe seguito dal punto e dal nome della costante, Math.PI

# CONSNIGLI PER LA PROGETTAZIONE DI UNA CLASSE
    ## Progettare la classe
    - Stabilire quali sono le caratteristiche essenziali degli oggetti della classe, e fare un elenco delle operazioni che sarà possibile compiere su di essi: "processo di astrazione"
    - "Definire e scrivere l'interfaccia pubblica": Ovvero scrivere l'intestazione della classe, definire i costruttori ed i metodi pubblici da realizzare, e scrivere la "firma" (specificatore di accesso, tipo di valore restituito, nome del metodo, eventuali parametri espliciti) di ciascuno di essi.
    - "Definire le variabili di esemplare ed eventuali variabili statiche": è necessario individuare tutte le variabili necessarie. Per ciascuna di esse si deve, poi, definire tipo e nome
    - Se un metodo non restituisce valori (ovvero il tipo del valore restituito è void), scrivere inizialmente un corpo vuoto, ovvero {}.
    - Se un metodo restituisce valori non void, scrivere inizalmente un corpo fittizzio contenente solo un enunciato di return

# GESTIONE DELLE ECCEZIONI
    - Un'eccezione è un evento anomalo che si verifica durante l'esecuzione di un programma e che interrompe il normale flusso di esecuzione.
    - Un'eccezione può essere generata da un'istruzione che non può essere eseguita correttamente, ad esempio perché i dati su cui deve operare non sono validi.
    - Un'eccezione può essere generata anche da un'istruzione che non può essere eseguita correttamente, ad esempio perché i dati su cui deve operare non sono validi.

        ## Record di attivazione
        - Quando un metodo entra in esecuzione viene creata nella memoria Stack una zona riservata, detta record di attivazione, che contiene tutte le informazioni necessarie per l'esecuzione del metodo, quali:
            - Parametri formali
            - Variabili locali 
            - Valore di ritorno
        
        ## Pila di attivazione
        - La zona di memoria che contiene i record di attivazione dei metodi invocati si chiama Stack perché si comporta come una pila di piatti o di libri.
            - Quando un metodo in esecuzione invoca un altro metodo viene aggiunto in cima alla pila il record di attivazione del metodo invocato
            - Quando un metodo termina la sua esecuzione viene tolto dalla pila e si torna ad eseguire il metodo che l'aveva invocato (quindi quello immediatamente "sotto") dal punto in cui eravamo rimasti.
        
        ## Lancio delle eccezioni
        - Il meccanismo generali di segnalazione di errori (o di condizioni di funzionamento anomale) in Java è basato sul lancio di eccezioni.
        - si dice anche che il metodo solleva o genera un'eccezione

        ## Le eccezioni in Java
        - Quando un metodo lancia un'eccezione..
            - il metodo termina immediatamente la sua esecuzione
            - il controllo passa al metodo che l'ha invocato
            - se anche questo metodo non gestisce l'eccezione, il controllo passa al metodo che l'ha invocato, e così via
            - se nessuno dei metodi che hanno invocato il metodo che ha lanciato l'eccezione gestisce l'eccezione, il programma termina con un messaggio di errore
        
        ## Gestire le eccezioni di input
        [java]
            String line = console.nextLine();
            int n = Integer.parseInt(line);
        [/java]
        - se l'utente inserisce una stringa che non rappresenta un numero intero, il metodo parseInt lancia un'eccezione di tipo NumberFormatException
        - si può gestire l'eccezione, segnalando l'errore all'utente e chiedendo di inserire nuovamente il dato numerico, anziché terminare il programma
            - possiamo intercettare l'eccezione e gestirla mediante un blocco try-catch
        [java]
            int n = 0;
            boolean valid = false;
            do
            {
                try
                {
                    String line = console.nextLine();
                    n = Integer.parseInt(line);
                    valid = true;
                }
                catch (NumberFormatException e)
                {
                    System.out.println("Inserire un numero intero");
                }
            }
        [/java]
        - il blocco try-catch è un blocco di codice che contiene un blocco try e uno o più blocchi catch

        ## Eccezioni numeriche e Scanner
        [java]
            int n = 0;
            boolean done = false;
            do
            {
                try
                {
                    n = console.nextInt();
                    done = true;
                }
                catch(java.util.InputMismatchException e)
                {
                    System.out.println("Riprova");
                    console.next();
                }
            } while (!done);
        [/java]
        - se invece di nextLine() uso nextInt(), le eccezioni ci sono lo stesso (le lancia nextInt invece di parseInt).
        - usando nextLine() invece di next() si pone rimedio a errore più gravi da parte dell'utente (che magari ha scritto "pippo pluto", con uno spazio, invece di un numero)
            - usando next() avrei eliminato pippo ma non pluto
        - si può anche pensare di svuotare completamente il flusso, nell'ipotesi che l'errore dell'utente si possa estendere su più righe, in questo modo
        [java]
            catch(java.util.InputMismatchException e)
            {
                System.out.println("Riprova");
                while(console.hasNextLine())
                {
                    console.nextLine();
                }
            }
        [/java]
        - con questo codice, togliamo tutta la riga scritta per errore dall'utente, quando avrebbe dovuto scrivere un numero e premere Invio
        [java]
            catch(java.util.InputMismatchException e)
            {
                System.out.println("Riprova");
                console.nextLine();
            }
        [/java]
        - basta anche questo, infatti è veramente difficile che l'utente sia riuscito a scrivere qualcos'altro dopo aver premuto invio e prima che venga eseguito di nuovo il metodo nextLine() del blocco try ( dopo la pulizia nel catch), quindi è fortemente probabile che veda prima il "Riprova".

        ## Scanner: comportamenti anomali
        - a volte nextInt e nextDouble si comportano in modo "strano", in realtà sempre in modo ben documentato.
            - leggono e "consumano" eventuali caratteri di spaziatura che possono precedere il numero che stanno cercando, ignorandoli
                - anche in caso di lancio di eccezione, questi caratteri saranno definitivamente consumati
            - leggono i caratteri provenienti dal flusso finché sono idonei a costruire un numero (intero o, rispettivamente, frazionario)
            - appena "vedono" un carattere non idoneo, interrompono la propria azione, lasciando all'inizio del flusso, senza "consumarlo", il carattere appena visto.
                - se hanno visto caratteri sufficienti a costruire un numero e SOLTANTO caratteri che costituiscono un numero, li "consumano" e restituiscono
                - altrimenti si verifica l'eccezione InputMismatchException e i caratteri NON vengono consumati, rimangono nel flusso, così come se il flusso viene chiuso prima che si sia visto un carattere non idoneo.
        - quando un'invocazione di next/nextInt/nextDouble è seguita da un'invocazione di nextLine
        
        ## Un altro uso di Scanner
        - E' possibile creare un oggetto della classe Scanner fornendo una stringa come parametro al costruttore
        - Scanner considera come delimitatori predefiniti gli spazi, i caratteri di tabulazione e i caratteri di "andata a capo". Questi e altri caratteri sono detti whitespaces, e sono risconosciuti dal metodo predicativo: Character.isWhitesplace(char c)
        - se come parametro di costruzione viene fornita una stringa, lo scanner esaminerà i caratteri di quella stringa (invece di esaminare i caratteri di un flusso)
            - può essere utile per scomporre una stringa in "parole"
            - non ha niente a che vedere con la redirezione del flusso di input
        - per accedere al token successivo si usa next() della classe Scanner
        - se l'elemento successivo non c'è next() lancia l'eccezione java.util.NoSuchElementException
        - poiché non è noto a priori il numero di "token" (parole ben delimitate da whitespaces) is utilizza "hasNext()"

        ## Diversi tipi di eccezioni
        - la gestione delle eccezioni di tipo Error e di tipo RuntimeException è facoltativa
            - se non vengono gestite e vengono lanciate, provocano la terminazione del programma
            - si dice che sono non controllate
                - descrivono problemi dovuti a errori del programmatore e che quindi non dovrebbero verificarsi
            - per questo motivo le eccezioni di tipo RuntimeException sono non controllate
            - non è obbligatorio catturarle traminte try-catch
        - la gestione delle altre eccezioni è obbligatoria (se non c'è, si ha un errore in compilazione)
            - si dice che sono controllate
                - descrivono problemi che possono verificarsi prima o poi, indipendentemente dalla bravura del programmatore
            - se si invoca un metodo che può lanciare un'eccezione controllata, è obbligatorio gestirla con try-catch
                - altrimenti viene segnalato un errore in compilazione
        - esistono eccezioni controllate e non controllate
            - eccezioni controllate: descrivono problemi che possono verificarsi prima o poi, indipendentemente dalla bravura del programmatore
                - per questo motivo le eccezioni di tipo IOException sono controllate
                - se si invoca un metodo che può lanciare un'eccezione controllata, è obbligatorio gestirla con try-catch
                    - altrimenti viene segnalato un errore in compilazione
            - eccezioni non controllate: descrivono problemi dovuti a errori del programmatore e che quindi non dovrebbero verificarsi
                - per questo motivo le eccezioni di tipo RuntimeException sono non controllate
                - non è obbligatorio catturarle traminte try-catch
            
    
    ## REALIZZAZIONE DEI METODI: argomenti inattesi (pre-condizioni)
        - spesso un metodo richiede che i suoi argomenti
            - siano di un tipo ben definito
                - questo viene garantito dal compilatore
            - abbiamo un valore che rispetti certi vincoli, ad esempio sia un numero positivo
                - ci sono tre modi per reagire ad argomenti inattesi
                    -  non fare niente: il metodo semplicemente termina la sua esecuzione senza alcuna segnalazione d'errore
                        - si può fare solo epr metodi con valore di ritorno void, altrimenti che cosa restituisce il metodo?
                        - se restituisce un valore casuale senza segnalare un errore, chi ha invocato il metodo probabilmente andrà incontro ad un errore logico
                    - terminare il programma con System.exit(1);
                        - System.exit(0): è andato tutto bene
                    - lanciare un'eccezione
                        - lanciare un'eccezione in risposta ad un parametro che non rispetta una precondizione è la soluzione più corretta in ambito professionale
                            - la libreria standard mette a disposizione tale eccezione
                                - "IllegalArgumentException"
                            [java]
                                public void deposit(double amount)
                                {
                                    if (amount < 0)
                                    {
                                        throw new IllegalArgumentException();
                                    }
                                    balance += amount;
                                }
                            [/java]
            
            ## Gestione dei casi degeneri
            - spesso (ma non sempre) i casi degeneri di un algoritmo vanno gestiti separatamente
                [java]
                    public static double sum(double[] values)
                    {
                        if (values.length == 0)
                        {
                            return 0; // inutile
                        }
                        double sum = 0;
                        for (int i=0; i<values.length; i++)
                        {
                            sum += values[i];
                        }
                        return sum;
                    }
                [/java]
                - qui è inutile gestire separatamente il caso in cui l'array ha lunghezza zero, 
            - l'obiettivo del programmatore era quello di rendere più veloce l'elaborazione nel caso di array di lunghezza zero
                - l'effetto ottenuto è quello di rendere più lenta l'elaborazione nel caso di array con lunghezza diversa da zero, perché la condizione va valutata sempre. 
            - in un metodo che calcola, invece, il valore medio dei dati presenti in un array, il caso di array di lunghezza zero va gestito separatamente, per evitare divisioni per zero
            [java]
                public static double average(double[] values)
                {
                    if (values.length == 0)
                    {
                        throw new IllegalArgumentException();
                    }
                    double sum = 0;
                    for (int i=0; i < values.length; i++)
                    {
                        sum = sum + values[i];
                    }
                    return sum / values.length;
                }
            [/java]
            - ESERCIZIO: FactorGenerator.java



# PASSAGGIO DI PARAMETRI
    - I parametri espliciti che compaiono nell'intestazione dei metodi e il parametro implicito "this" si dicono "Parametri Formali" del metodo
        [java]
            public void transfer(BankAccount toAccount, double amount)
            {
                this.balance = this.balance - amount
                toAccount.balance += amount;
            }
        [/java]
    - I parametri forniti nell'invocazione ai metodi si dicono "Parametri Effettivi" del metodo
        [java]
            BankAccount acct1 = new BankAccount();
            BankAccount acct2 = new BankAccount();
            acct1.transfer(acct2, 100);
        [/java]
    - Al momento dell'esecuzione dell'invocazione del metodo, i parametri effettivi sono copiati nei parametri formali
    - Le "variabili parametro" di un metodo vengono automaticamente definite e inizializzate ogni volta che il metodo viene invocato
        - Nel metodo invocante: l'interprete valuta le espressioni usate come parametri: ciascuna di queste valutazioni genera un valore di un certo tipo (primitivo o oggetto). Ad esempio vede che money contiene 100.
        - Nel metodo invocato: PRIMA della sua esecuzione, tali valori vengono usati in normali assegnazioni di valori iniziali per le variabili parametro, che, però, sono operazioni implicite e non visibili nel codice sorgente. Ad esempio, il valore 100 viene assegnato alla variabile locale amount.

    ## Modificare aprametri numerici
        Vogliamo scrivere un emtodo increment che ha il compito di fornire un nuovo valore per una variabile di tipo numerico
        [java]
            public class IncrementaNuemro
            {
                public static void main(String[] args)
                {
                    int x = 3;
                    IncrementUno(x);
                    System.out.println(x);
                }

                public static void IncrementUno(int n)
                {
                    n++;
                }
            }
        [/java]
        Invocando il metodo il valore viene copiato in n, ma n è una variabile locale del metodo, quindi non viene modificato il valore di x.
        In IncrementUno abbiamo una variabile locale n che contiene una copia del valore di x, ma non è la stessa variabile di x.
        !Come si fa?
        [java]
            public class IncrementaNuemro
            {
                public static void main(String[] args)
                {
                    int x = 3;
                    x = IncrementUno(x);
                    System.out.println(x);
                }

                public static int IncrementUno(int n)
                {
                    return n++;
                }
            }
        [/java]

    ## Modificare parametri oggetto
        - Un metodo può invece modificare l ostato di un oggetto passato come parametro (implicito o esplicito)
        [java]
            // classe BankAccount // trasferisce denaro dla conto this al conto to account
            public void transfer(BankAccount toAccount, double amount)
            {
                withdraw(amount);           // prelievo dal conto this
                toAccount.deposit(amount);  // deposito sul conto toAccount
            }

            BankAccount a = new BankAccount(10);
            BankAccount b = new BankAccount();

            a.transfer(b, 5); // trasferisce 5 da a a b
        [/java]
        - ma non può modificare il riferimento contenuto nela variabile oggetto che ne costituisce il parametro effettivo
        [java]
        // NON FUNZIONA
        public static void swapAccounts(BankAccount x, BankAccount y)
        {
            BankAccount temp = x;
            x = y;
            y = temp;

            BankAccount a = new BankAccount(10);
            BankAccount b = new BankAccount();

            swapAccounts(a, b); // non succede nulla alle variabili a e b
        }
        [/java]

    ## Parametri formali ed effettivi
    - Al momento dell'esecuzione dell'invocazione del metodo, i parametri effettivi sono copiati nei parametri formali.

    ## Ciclo di vita di una variabile
        - In Java esistono quattro tipi di variabili
            - variabili locali
                - viene creata quando viene dichiarata e viene distrutta quando il metodo termina la sua esecuzione
                - se non è definita all'interno di un blocco di enunciati, viene eliminata quando l'esecuzione del programma esce dal metodo in cui la variabile viene definita
            - variabili parametro
                - viene creata quando viene invocato il metodo e viene distrutta quando il metodo termina la sua esecuzione
            - variabili di esemplare o di istanza
                - viene creata quando viene creato l'oggetto a cui appartiene e viene distrutta quando l'oggetto viene distrutto
                - un oggetto viene eliminato dalla JVM quando non esistono più riferimenti ad esso
                    - la zona di memoria riservata all'oggetto viene "riciclata", cioè resa di nuovo libera, dal raccoglitore di rifiuti (garbage collector) della JVM, che controlla periodicamente se ci sono oggetti da eliminare
            - variabili statiche o di classe
                - viene creata quando viene caricata la classe e viene distrutta quando il programma termina la sua esecuzione
        
        ### Inizializzazione di una variabile
            - Le variabili di esemplare e le variabili statiche, se non sono inizializzate esplicitamente, vengono inizializzate esplicitamente, vengono inizializzate automaticamente ad un valore predefinito
                - zero per le variabili id tipo numerico e carattere
                - false per le variabili di tipo boolean
                - null per le variabili oggetto
            - le variabili parametro vengono inizializzate copiando il valore dei parametri effettivi usati nell'invocazione del metodo
            - le variabili locali non vengono inizializzate automaticamente, e il compilatore effettua un controllo semantico impedendo che vengano utilizzate prima di aver ricevuto un valore

        ### Ambito di visibilità di una variabile
            - l'ambito di visibilità di una variabile indica la parte del codice nel quale è lecito usare la variabile (per leggere e/o scrivere il suo valore)
            - per le variabili locali e le variabili parametro, l'ambito di visibilità è quello che determina anche il relativo ciclo di vita
            - per le variabili di esemplare e le variabili statiche, l'ambito di visibilità dipende dalla dichiarazione public o private
                - public: sono visibili in ogni parte del programma
                - private: sono visibili solo all'interno della classe in cui sono dichiarate
            - è anche possibile dichiararle senza indicare uno specificatore di accesso (accesso di default)
                - sono così visibili anche all'interno di classi che si trovano nello stesso package (cioè di file sorgenti che si trovano nella stessa cartella)
                - esiste anche un accesso protetto (protected) che vedremo più avanti
        
        ### Conflitti tra nomi di variabili
            - Conoscere l'ambito di visibilità e il ciclo di vita di una variabile è molto importante per capire quando e dove è possibile usare di nuovo il nome di una variabile che è già stato usato
            - le regole appena viste consentono di usare, in metodi diversi della stessa classe, variabili locali o variabili parametro con gli stessi nomi, senza creare alcun conflitto, perché: 
                - i rispettivi ambiti di visibilità non sono sovrapposti
            - in questi casi le variabili definite nuovamente non hanno alcuna relazione con le precedenti



# GESTIONE DI FILE IN JAVA

    ## Reindirizzamento di input e output
        [java]
        import java.util.Scanner;

        public class sum
        {
            public static void main(String[] args)
            {
                Scanner console = new Scanner(System.in);
                double sum = 0;
                while (console.hasNextDouble())
                {
                    sum += console.nextDouble();
                }
                System.out.println(sum);
                console.close();
            }
        }
        [/java]
        - Usando il programma Sum (Sum.java) si inseriscono dei numeri da tastiera, che al termine non vengono memorizzati
            - per sommare una serie di numeri, bisogna digitarli tutti, ma non ne rimane traccia!
        - Alternativa interessante e utile: il programma legge i numer ida un File
            - questo si può fare con il reindirizzamento dell'input standard
                - Il reindirizzamento dell'input standard, sia nei sistemi Unix sia nei sistemi Windows, si indica con il carattere < seguito dal nome del file da cui ricevere l'input
                - [java] java Sum < input.txt [/java]
                - Si dice che il file numeri.txt viene collegato all'input standard
                - Il programma non ha bisogno di alcuna istruzione particolare, semplicemente System.in non sarà più collegato alla tastiera ma al file specificato. 
                    - la tastiera "non esiste più" per il programma, quindi non si può più inserire input da tastiera
                - a volte è comodo anche il reindirizzamento dell'output
                    - ad esempio, quando il programma produce molte righe di output, che altrimenti scorrono velocemente sullo schermo senza poter esser lette 
                    [java]java Sum > output.txt[/java]
                        - se il file output.txt non esiste viene creato, se esiste viene sovrascritto
                        - per non sovrascrivere il file, ma aggiungere le righe alla fine, si usa il doppio carattere >>
                - I due reindirizzamenti possono anche essere combinati
                    [java]java Sum < input.txt > output.txt[/java]
                    - in questo caso il file output.txt viene creato o sovrascritto, ma il file input.txt non viene modificato
                    - il file input.txt viene letto e il file output.txt viene scritto
                    - il file output.txt contiene il risultato della somma dei numeri contenuti in input.txt
    
    ## Canalizzazioni ("Pipes")
        - Supponiamo di aver scritto la classe Split che scrive ciascuna parola ricevuta in ingresso su una riga di output separatamente
            [java] java Split < testo.txt [/java]
        - una elaborazione molto comune consiste nell'ordinare poi tali parole. Questa elaborazione è talmente comune che quasi tutti i sistemi operativi hanno un programma sort.
        - in alternativa, possiamo scrivere una classe Sort
        - per ottenere le parole di testo.txt una per riga e ordinate, abbiamo bisogno di un file temporaneo
        [java]
            java Split < testo.txt > temp.txt
            sort < temp.txt > testoOrdinato.txt
        [/java]
        - il file temporaneo temp.txt serve soltanto per memorizzare il risultato intermedio, prodotto dal primo programma e utilizzato dal secondo
        - questa situazione è talmente comune che quasi tutti i sistemi operativi offrono un'alternativa
        - anziché utilizzare un file temporaneo per memorizzare l'output prodotto da un programma che deve servire da input per un altro programma, si usa una canalizzazione ("pipe").
            [java] java Split < testo.txt | sort | sort > testoOrdinato.txt [/java]
        - la canalizzazione può anche prolungarsi, ad esempio, possiamo eliminare eventuali parole ripetute da testoOrdinato.txt
            [java] java Split < testo.txt | sort | java Unique > testoOrdinato.txt [/java]
        
    ## Formattazione di numeri
        - Java fornisce il metodo "printf"
            - il primo parametro esplicito è una stringa che contiene una sequenza di caratteri e di specificatori di formato
            - i parametri successivi sono i valori da formattare secondo i formati specificati
                [java] System.out.printf("Total:%5.2f", total); [/java]
                - il formato %5.2f indica che il valore total deve essere formattato come un numero in virgola mobile con 5 cifre totali, di cui 2 dopo la virgola
                - questo formato viene applicato alla variabile total, che è il secondo parametro del metodo
                - se il valore total è 123.456, il risultato sarà "Total:123.46"
        
        ### Tipi di formato e modificatori di formato
        d -> intero decimale
        x -> intero esadecimale
        o -> intero ottale
        f -> numero in virgola mobile
        e -> numero in virgola mobile in notazione scientifica
        g -> numero in virgola mobile in notazione scientifica o decimale
        s -> stringa
        n -> carattere di andata a capo
        - -> allineamento a sinistra
        + -> segno anche per i numeri positivi
        0 -> riempimento con zeri
        , -> separatore delle migliaia
        . -> separatore decimale
        ( -> parentesi per i numeri negativi
        % -> carattere percentuale

    ## Gestione di file all'interno di un programma
        - La gestione dei file avviene interagendo con il sistema operativo mediante classi del pacchetto "java.io" della libreria standard

        ### Leggere un file di testo
            - Prima di leggere caratteri da un file (esistente) occorre aprire il file in lettura
                - questa operazione si traduce in java nella creazione di un oggetto di tipo FileReader
                [java] FileReader reader = new FileReader("file.txt"); [/java]
                - il costruttore necessita del nome del file (con eventuale percorso) sotto forma di stringa
                - se il file non esiste, viene lanciata l'eccezione FileNotFoundException, che dev'essere obbligatoriamente gestita
                [java]
                    try
                    {
                        FileReader reader = new FileReader("file.txt");
                    }
                    catch (FileNotFoundException e)
                    {
                        System.out.println("File non trovato");
                    }
                [/java]
            - Si costruisce un'esemplare di Scanner che scansiona il file esattamente come farebbe con il flusso di ingresso standard o con una stringa
                [java]
                    try
                    {
                        FileReader reader = new FileReader("file.txt");
                        Scanner in = new Scanner(reader);
                        while (in.hasNextLine())
                        {
                            String line = in.nextLine();
                            System.out.println(line);
                        }
                    }
                    catch (FileNotFoundException e)
                    {
                        System.out.println("File non trovato");
                    }
                [/java]
            - al termine della lettura del file, occorre chiudere il file
                - questa operazione si traduce in java nella chiamata al metodo close dell'oggetto FileReader
                [java]
                    try
                    {
                        FileReader reader = new FileReader("file.txt");
                        Scanner in = new Scanner(reader);
                        while (in.hasNextLine())
                        {
                            String line = in.nextLine();
                            System.out.println(line);
                        }
                        
                        try
                        {
                            reader.close();
                        }
                        catch (IOException e)
                        {
                            System.out.println("Errore nella chiusura del file");
                        }

                    }
                    catch (FileNotFoundException e)
                    {
                        System.out.println("File non trovato");
                    }
                [/java]
            - Eccezioni:
                - FileNotFoundException: sottoclasse di IOException, viene lanciata se il file non esiste
                - IOException: viene lanciata se si verifica un errore durante la lettura del file
                    - Si gestice inplicitamente anche FileNotFoundException
                - se voglio distinguerli devo prima gestire FileNotFoundException

        ### Scrivere un file di testo
            - Prima di scrivere caratteri su un file (esistente) occorre aprire il file in scrittura
                - questa operazione si traduce in java nella creazione di un oggetto di tipo PrintWriter
                [java] FileWriter writer = new FileWriter("file.txt"); [/java]
                - il costruttore necessita del nome del file (con eventuale percorso) sotto forma di stringa
                - se il file non esiste, viene creato
                - se il file esiste, viene sovrascritto
                [java]
                    try
                    {
                        FileWriter writer = new FileWriter("file.txt");
                    }
                    catch (IOException e)
                    {
                        System.out.println("Errore nella creazione del file");
                    }
                [/java]
            - Si costruisce un'esemplare di PrintWriter che scrive sul file esattamente come farebbe con il flusso di uscita standard
                [java]
                    try
                    {
                        FileWriter writer = new FileWriter("file.txt");
                        PrintWriter out = new PrintWriter(writer);
                        out.println("Hello World");
                        out.println(123);
                        out.close();
                    }
                    catch (IOException e)
                    {
                        System.out.println("Errore nella creazione del file");
                    }
                [/java]
            - al termine della scrittura del file, occorre chiudere il file
                - questa operazione si traduce in java nella chiamata al metodo close dell'oggetto FileWriter
                [java]
                    try
                    {
                        FileWriter writer = new FileWriter("file.txt");
                        PrintWriter out = new PrintWriter(writer);
                        out.println("Hello World");
                        out.println(123);
                        out.close();
                    }
                    catch (IOException e)
                    {
                        System.out.println("Errore nella creazione del file");
                    }
                [/java]
            - Eccezioni:
                - IOException: viene lanciata se si verifica un errore durante la scrittura del file
                - se voglio distinguerli devo prima gestire FileNotFoundException
    
    ## try-with-resources
        - La gestione di file in Java è molto verbosa
            - occorre dichiarare le variabili che rappresentano i file
            - occorre gestire le eccezioni
            - occorre chiudere i file
        - Per semplificare la gestione dei file, Java 7 ha introdotto il costrutto try-with-resources
            - permette di dichiarare le variabili che rappresentano i file all'interno del blocco try
            - permette di non gestire le eccezioni
            - permette di non chiudere i file
        - Il costrutto try-with-resources si basa sul fatto che le classi che rappresentano i file implementano l'interfaccia AutoCloseable
            - questa interfaccia contiene un solo metodo, close, che viene invocato automaticamente alla fine del blocco try
            - il metodo close può lanciare un'eccezione, che viene gestita automaticamente dal costrutto try-with-resources
            - il costrutto try-with-resources può gestire più di un file
                [java]
                    try (FileReader reader = new FileReader("file.txt");
                        Scanner in = new Scanner(reader);
                        FileWriter writer = new FileWriter("file.txt");
                        PrintWriter out = new PrintWriter(writer))
                    {
                        while (in.hasNextLine())
                        {
                            String line = in.nextLine();
                            out.println(line);
                        }
                    }
                    catch (IOException e)
                    {
                        System.out.println("Errore nella creazione del file");
                    }
                [/java]
            - Eccezioni:
                - IOException: viene lanciata se si verifica un errore durante la lettura o la scrittura del file
                - se voglio distinguerli devo prima gestire FileNotFoundException
# RICORSIONE
    - la definizione ricorsiva di una funzione è una definizione che usa la funzione stessa
    - Quandp un metodo ricorsivo invoca se stesso, la macchina virtuale Java esegue le stesse azioni che vengono eseguite quando viene invocato un metodo qualsiasi
        - sospende l'esecuzione del metodo invocante
        - esegue il metodo invoato fino alla sua terminazione
        - riprende l'esecuzione del metodo invocante dal punto in cui era stata sospesa

    ## Il calcolo del fattoriale
        - Il fattoriale di un numero intero positivo n, indicato con "n!", è il prodotto di tutti i numeri interi positivi minori o uguali a n
            - 0! = 1
            - 1! = 1
            - 2! = 2 * 1 = 2
            - 3! = 3 * 2 * 1 = 6
            - 4! = 4 * 3 * 2 * 1 = 24
            - 5! = 5 * 4 * 3 * 2 * 1 = 120
            - 6! = 6 * 5 * 4 * 3 * 2 * 1 = 720
            - 7! = 7 * 6 * 5 * 4 * 3 * 2 * 1 = 5040
            - 8! = 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 40320
            - 9! = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 362880
            - 10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 3628800
        - questa funzione, molto usata nel calcolo combinatorio, è definita ricorsivamente
            - 0! = 1
            - n! = n * (n-1)! per n > 0
        => CREATO FILE Factorial.java

    ## Progettazione di metodi ricorsivi
        - Si scompone il problema in una porzione "semplice" e in un'altra parte, simile a quella iniziale ma di "dimensione" inferiore
        - Nel metodo, si eseguono le fasi seguenti (la prima e la seconda fase possono scambiarsi, dipende dal problema)
            - Risolvere la porzione semplice
                - a volte c'è solo questa fase (caso base) e allora si dice che il metodo è ricorsivo terminale
            - effettuare una chiamata ricorsiva per risolvere il problema di dimensione inferiore
                - Importante: non ci si preoccupa di come verrà risolta questa parte, altrimenti non si riesce a comprendere il funzionamento del metodo
            - combinare i risultati ottenuti dalle due fasi precedenti per ottenere il risultato finale
        
        ### Caso Base
            - Prima regola (condizione necessaria)
                - Il metodo ricorsivo deve fornire la soluzione del problema in almento un caso particolare, senza ricorrere a un'invocazione ricorsiva
                    - questo caso particolare si chiama caso base
            - Seconda regola (condizione necessaria)
                - il metodo ricorsivo deve effettuare l'invocazione ricorsiva dopo aver semplificato il problema
                    - se l'invocazione ricorsiva viene effettuata prima di aver semplificato il problema, il metodo non termina mai
            - Le regole appena viste sono fondamentali per poter dimostrare che la soluzione ricorsiva di un problema sia un algoritmo
                - in particolare, che arrivi a conclusione in un numero finito di passi
            - Si potrebbe pensare che le invocazioni ricorsive si possano succedere una dopo l'altra, all'infinito; invece, se
                a. ad ogni invocazione il problema diventa sempre più semplice e si avvicina al caso base
                b. la soluzione del caso base non richiede RICORSIONE
            allora certamente la soluzione viene calcolata in un numero finito di passi, per quanto complesso possa essere il problema.

        ### Ricorsione infinita
            - Se manca il caso base, il metodo ricorsivo continua a invocare se stesso "all'infinito"
            - se il problema non viene semplificato ad ogni invocazione ricorsiva, il metodo ricorsivo continua a invocare se stesso "all'infinito"
            - Dato che la lista dei metodi "in attesa" si allunga indefinitamente, l'ambiente runtime esaurisce la memoria disponibile per tener traccia di questa lista e il programma termina con un errore.

        ### Eliminare la Ricorsione
            - Esistono diversi tipi di Ricorsione
            - Tail recursion
                - è un tipo di ricorsione in cui l'invocazione ricorsiva è l'ultima operazione eseguita dal metodo
                - in questo caso, la ricorsione può essere eliminata
                - la ricorsione in coda può sempre essere agevolmente eliminata, trasformando il metodo ricorsivo in un metodo che usa un ciclo
            - ricorsione multipla
                - è un tipo di ricorsione in cui il metodo ricorsivo effettua più di una invocazione ricorsiva
                
        ### Ricorsione multipla
            - La ricorsione multipla va usata con molta cautela
            - Eseguendo il calcolo dei numeri di Fibonacci di ordine crescente
                - si nota che il tempo di esecuzione cresce in modo esponenziale, servono quasi 3 milioni di invocazioni per calcolare Fib(31), quando in realtà basterebbe eseguire 30 addizioni

        ### Ricorsione strutturale
            - La ricorsione strutturale sfrutta caratteristiche intrinseche della struttura di memorizzazione dei dati di un problema
                - Ad esempio, un array di n elementi può essere visto come la concatenazione di un elemento e di un array di n-1 elementi
                    - Una diversa suddivisione strutturale spesso utilizzata nella ricorsione operante su array identifica due sotto-problemi relativi a due metà dell'array stesso
                - Il medesimo ragionamento è valido per una stringa
                - La ricorsione strutturale è molto usata per la risoluzione di problemi su alberi e grafi
                    - Ad esempio, per calcolare l'altezza di un albero binario, si può sfruttare la ricorsione strutturale, considerando l'altezza della radice come 1 più l'altezza del sotto-albero sinistro o destro, a seconda di quale sia più alto

# COMPLESSITA' COMPUTAZIONALE
    - La complessità computazionale di un algoritmo è una misura della quantità di risorse (tempo e spazio) necessarie per eseguire l'algoritmo
    
    ## Analisi Sperimentale
        - Rilevare le prestazioni:
            - Per valutare l'efficienza temporale di un algoritmo si misura il tempo impiegato per la sua esecuzione su insiemi di dati di dimensioni diverse, per poi magari fare un grafico
            - Il tempo non va misurato con un cronometro, perché il tempo di esecuzione di un programma dipende da molti fattori, come ad esempio:
                - la velocità del processore
                - la quantità di memoria disponibile
                - il sistema operativo
                - il linguaggio di programmazione
                - il compilatore
                - l'ottimizzazione del codice
                - la dimensione dei dati
            - Tali componenti sono, poi, anche variabili nel tempo, da un'esecuzione all'altra
            - Il tempo di esecuzione di un algoritmo va misurato all'interno del programma
            - Si può usare il metodo statico System.currentTimeMillis() che, a ogni invocazione, restituisce un valore di tipo long che rappresenta
                - il numero di millisecondi da un evento di riferimento (mezzanotte del 1/1/1970)
            - Ciò che interessa è la "differenza" tra i due valori
                [java]
                    long start = System.currentTimeMillis();
                    // eseguire l'algoritmo
                    long end = System.currentTimeMillis();
                    long elapsed = end - start;
                [/java]

            - POSSIBILE APPLICAZIONE:
                - Data una stringa di caratteri di lunghezza n voglio sapere qual'è il numero di sottostringhe presenti
                - Oppure, elencare tutte le sottostringhe di una stringa
                    - le coppie di indici rappresentano le posizioni di inizio e fine di ciascuna sottostringa
                    - attenzione! se volessi stampare anche le sottostringhe dovrei tener conto anche delle operazioni di estrazione della sottostringa
                
# ORDINAMENTO DI DATI
!# CREATO FILE SortingAlgorithms.java
    - Un problema molto frequente nell'elaborazione dei dati consiste nell'ordinamento dei dati stessi, secondo un criterio prestabilito
        - numeri in ordine crescente/decrescente, alfabetico, ecc.
    - Una sequenza di n "oggetti" confrontabili
        - si dice che un oggetto è confrontabile se è possibile stabilire se è maggiore, minore o uguale ad un altro oggetto della stessa classe
        - una sequenza di oggetti si dice ordinata qunado gli oggetti sono disposti in ordine crescente o decrescente
    - Tra i più studiati problemi in informatica
        - fucina di idee algoritmiche
        - moltissime soluzioni
    - Analisi di complessità computazionale
        - Caso migliore, caso peggiore, caso medio
    - L'ordinamento è un passaggio chiave su cui molti altri algoritmi sono costruiti.
    - Usiamo l'ordinamento per essere più efficienti nel..
        - Cercare un valore
        - Trovare min/max o k-th min/max
        - Ricerca della coppia di elementi più vicina
            - Verificare unicità di un elemento (o trovare duplicati)
        - Distribuzione di frequenza degli elementi
        - Intersezione / unione di insiemi
    - Metodi studiati in questo corso:
        - Selection Sort
        - Insertion Sort
        - Merge Sort
    
    - Nei problemi di ordinamento si parla di
        - ordinamento "sul posto" quando il metodo di ordinamento riceve un contenitore e ne ordina il contenuto
            - non restituisce nulla
            - il metodo invocante si ritrova il contenitore ordinato
        - ordinamento "non sul posto" quando il metodo di ordinamento riceve un contenitore e ne restituisce un altro contenente gli stessi elementi, ma in ordine; il contenitore ricevuto non viene modificato
    - I metodi che ordinano array sono "metodi statici"
        - Devono ricevere un array come parametro, ma questo non può essere il parametro implicito del metodo, perché non esiste la "classe array" in cui definire il metodo di ordinamento
    - Con modifiche minime, gli stessi algoritmi possono ordinare:
        - array "riempiti solo in parte", fornendo la dimensione logica come parametro aggiuntivo
        - porizoni di array, fornendo due parametri aggiuntivi
            - l'indice di inizio e l'indice di fine della porzione da ordinare
    
    ## Selection Sort
        - Per semplicità, analizzeremo prima algoritmi per ordinare numeri memorizzati in un array
        - Il Selection Sort è un algoritmo di ordinamento "sul posto"
            - non richiede memoria aggiuntiva
            - non crea un nuovo array ordinato, ma ordina l'array ricevuto come parametro
        - Per prima cosa, bisogna trovare la posizione dell'elemento minimo presente nell'intero array
            - si confronta l'elemento in posizione 0 con tutti gli altri elementi dell'array
            - se si trova un elemento minore, si memorizza la sua posizione
            - si scambia l'elemento in posizione 0 con l'elemento minimo trovato
        - Essendo l'elemento minimo, la sua posizione finale corretta nell'array ordinato è 0
        - Si ripete la stessa operazione per l'elemento in posizione 1, che viene scambiato con l'elemento minimo trovato
        - Per ordinare array riempiti solo in parte basta aggiungere un parametro che indica la dimensione logica dell'array
        - Per ordinare una porzione di array, basta aggiungere due parametri che indicano l'indice di inizio e l'indice di fine della porzione da ordinare